for (q in Q) {
proj <- proy.ortogonal.12(u_k, q)
prev_u_k <- u_k
u_k <- (function(prev, pj) {
function(x) prev(x) - pj(x)
})(prev_u_k, proj)
}
Q[[length(Q) + 1]] <- u_k
}
Q
}
# Ortogonalización + normalización (segura)
gs.ortonormal.12 <- function(base) {
base_ortogonal <- gs.ortogonal.12(base)
lapply(base_ortogonal, function(f) {
n <- norma.12(f)
if (n == 0 || !is.finite(n)) {
stop("❌ Error: norma no finita o cero.")
}
function(x) f(x) / n
})
}
# Funciones base
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
# Construcción de la base ortonormal
ortonormal <- gs.ortonormal.12(base)
# Producto punto clásico en R^n
prod.punto.euclideo <- function(x, y) sum(x * y)
# Producto interno en L^2[0,1]: integra f(x)*g(x) de 0 a 1
prod.punto.L2 <- function(f, g) {
h <- Vectorize(function(x) f(x) * g(x))
integrate(h, lower = 0, upper = 1)$value
}
# Norma inducida
norma <- function(v, prod.punto) {
sqrt(prod.punto(v, v))
}
# Proyección ortogonal de u sobre v con producto interno genérico
proy.ortogonal <- function(u, v, prod.punto) {
coef <- prod.punto(u, v) / prod.punto(v, v)
function(x) coef * v(x)
}
# Ortogonalización de Gram-Schmidt genérica
gs.ortogonal <- function(base, prod.punto) {
Q <- list()
for (k in seq_along(base)) {
u_k <- base[[k]]
for (q in Q) {
proy <- proy.ortogonal(u_k, q, prod.punto)
u_k <- (function(prev, pj) {
function(x) prev(x) - pj(x)
})(u_k, proy)
}
Q[[length(Q) + 1]] <- u_k
}
return(Q)
}
# Ortonormalización genérica
gs.ortonormal <- function(base, prod.punto) {
ortogonal <- gs.ortogonal(base, prod.punto)
return(lapply(ortogonal, function(f) {
nrm <- norma(f, prod.punto)
function(x) f(x) / nrm
}))
}
base.funciones <- list(
function(x) 1,
function(x) x,
function(x) x^2
)
# Ortonormalización en L2[0,1]
ortonormal.L2 <- gs.ortonormal(base.funciones, prod.punto.L2)
# Visualizamos los coeficientes en una cuadrícula
curve(ortonormal.L2[[1]](x), 0, 1, col = "blue", lwd = 2)
curve(ortonormal.L2[[2]](x), 0, 1, col = "red", add = TRUE, lwd = 2)
curve(ortonormal.L2[[3]](x), 0, 1, col = "green", add = TRUE, lwd = 2)
legend("topright", legend = c("φ₁", "φ₂", "φ₃"), col = c("blue", "red", "green"), lwd = 2)
numTerminos(x_n2,0,tol)
while (abs(x_n(contador+1)-x)<Tol) {
contador = contador+1
}
while (abs(x_n(contador+1)-x)>Tol) {
contador = contador+1
}
numTerminos <- function(x_n, x, Tol) {
contador = 0
while (abs(x_n(contador+1) - x) > Tol) {
contador = contador + 1
}
return(contador)
}
x_n1 <- function(n) 1/n
x_n2 <- function(n) 1/n^2
tol <- 5*10^-2
numTerminos(x_n1, 0, tol)  # sucesión 1/n
numTerminos(x_n2, 0, tol)  # sucesión 1/n^2
numTerminos <- function(x_n, x, Tol) {
contador = 1
while (abs(x_n(contador) - x) > Tol) {
contador = contador + 1
}
return(contador)
}
x_n1 <- function(n) 1/n
x_n2 <- function(n) 1/n^2
tol <- 5*10^-2
numTerminos(x_n1, 0, tol)  # sucesión 1/n
numTerminos(x_n2, 0, tol)  # sucesión 1/n^2
#| code-fold: true
punto.fijo <- function(p0, tol, n, g) {
i <- 1
p0_temp <- p0
while (i <= n) {
p <- g(p0_temp)
if (abs(p - p0_temp) < tol) {
return(list("valor" = p, "iteraciones" = i))
}
i <- i + 1
p0_temp <- p
}
return(NULL)
}
punto.fijo.rec <- function(p0, tol, n, g) {
p1 <- g(p0)
if (abs(p1 - p0) < tol || n < 1) {
if (n >= 1) {
return(p1)
}
else{
return(Inf)
}
}
else{
return(punto.fijo.rec(p1, tol, n - 1, g))
}
}
f1 <- function(x) sqrt(1 + 1/x)
punto.fijo(1, 1e-8, 20, f1)
punto.fijo.rec(1, 1e-8, 20, f1)
#| code-fold: true
biseccion <- function(a, b, tol, n, g) {
i <- 1
a1 <- a
b1 <- b
if (g(a) * g(b) > 0) {
return("No se cumplen las hipotesis")
}
else{
while (i <= n) {
x <- (a1 + b1) / 2
if (g(a1) * g(x) > 0) {
a1 <- x
}
else{
b1 <- x
}
if (abs(b1 - a1) < tol) {
return(list("valor" = x, "iteraciones" = i))
}
i <- i + 1
}
return(NULL)
}
}
biseccion.rec <- function(a, b, tol, n, g) {
a1 <- a
b1 <- b
x <- (a + b) / 2
if (abs(b1 - a1) < tol || n < 1) {
if (n >= 1) {
return(x)
}
else{
return(x)
}
}
else {
if (g(a) * g(x) > 0) {
return(biseccion.rec(x, b1, tol, n - 1, g))
}
else {
return(biseccion.rec(a1, x, tol, n - 1, g))
}
}
}
f <- function(x) (cos(x))^2 - 2 * sin(x)
biseccion(0, 1, 1e-8, 100, f)
biseccion.rec(0, 1, 1e-8, 100, f)
#| code-fold: true
newton.raphson <- function(x0, tol, n, f, df) {
i <- 1
x0_temp <- x0
while (i <= n) {
x <- x0_temp - f(x0_temp) / df(x0_temp)
if (abs(x - x0_temp) < tol) {
return(list("valor" = x, "iteraciones" = i))
}
i <- i + 1
x0_temp <- x
}
return(NULL)
}
newton.raphson.rec <- function(x0, tol, n, f, df) {
x0_temp <- x0
x <- x0_temp - f(x0_temp) / df(x0_temp)
if (abs(x - x0) < tol || n < 1) {
if (n >= 1) {
return(x)
}
else{
return(NULL)
}
}
else{
return(newton.raphson.rec(x, tol, n - 1, f, df))
}
}
f <- function(x) (cos(x))^2 - 2 * sin(x)
df <- function(x) - 2 * cos(x) * sin(x) - 2 * sin(x)
newton.raphson(0.5, 1e-8, 100, f, df)
newton.raphson.rec(0.5, 1e-8, 100, f, df)
#| code-fold: true
secante <- function(x0, x1, tol, n, f) {
i <- 2
x0.temp <- x0
x1.temp <- x1
while (i <= n) {
x <- x1.temp - ((x0.temp - x1.temp) * f(x1.temp)) / (f(x0.temp) - f(x1.temp))
if (abs(x - x0.temp) < tol) {
return(list("valor" = x, "iteraciones" = i))
}
x0.temp <- x1.temp
x1.temp <- x
i <- i + 1
}
return(NULL)
}
secante.rec <- function(x0, x1, tol, n, f) {
x <- x1 - ((x0 - x1) * f(x1)) / (f(x0) - f(x1))
if (abs(x - x0) < tol || n < 1) {
if (n >= 1) {
return(x)
}
else{
return(NULL)
}
}
else{
return(secante.rec(x1, x, tol, n - 1, f))
}
}
g <- function(x) cos(x) - x^2
secante(0, 1, 1e-8, 100, g)
secante.rec(0, 1, 1e-8, 100, g)
#| code-fold: true
steffensen <- function(x0, tol, n, f) {
i <- 2
x0.temp <- x0
while (i <= n) {
x1 <- f(x0.temp)
x2 <- f(x1)
x <- x0.temp - (x1 - x0.temp)^2 / (x2 - 2 * x1 + x0.temp)
if (abs(x - x0.temp) < tol) {
return(list("valor" = x, "iteraciones" = i))
}
i <- i + 1
x0.temp <- x
}
return(NULL)
}
steffensen.rec <- function(x0, tol, n, f) {
x1 <- f(x0)
x2 <- f(x1)
x <- x0 - (x1-x0)^2/(x2-2*x1+x0)
if(abs(x - x0) < tol || n < 1){
if(n>=1){
return(x)
}
else{
return(NULL)
}
}
else{
return(steffensen.rec(x, tol, n-1, f))
}
}
f1 <- function(x) sqrt(1 + 1/x)
steffensen(1, 1e-8, 100, f1)
steffensen.rec(1, 1e-8, 100, f1)
#| code-fold: true
regula.falsi <- function(a,b, tol, n, f){
i <- 1
a.temp <- a
b.temp <- b
while (i <= n) {
x <- (a.temp*f(b.temp) - b.temp*f(a.temp))/(f(b.temp) - f(a.temp))
if(f(a.temp)*f(x) > 0){
a.temp <- x
}
else{
b.temp <- x
}
if(abs(b.temp-a.temp) < tol) {
return(list("valor" = x, "iteraciones" = i))
}
i <- i + 1
}
return(NULL)
}
regula.falsi.rec <- function(a, b, tol, n, f) {
a.temp <- a
b.temp <- b
x <- (a.temp*f(b.temp) - b.temp*f(a.temp))/(f(b.temp) - f(a.temp))
if(abs(b.temp-a.temp)<tol || n<1){
if(n>=1){
return(x)
}
else{
return(NULL)
}
}
else{
if(f(a)*f(x) > 0){
return(regula.falsi.rec(x, b.temp, tol, n-1, f))
}
else{
return(regula.falsi.rec(a.temp, x, tol, n-1, f))
}
}
}
f <- function(x) (cos(x))^2 - 2 * sin(x)
regula.falsi(0, 1, 1e-8, 100, f)
regula.falsi.rec(0, 1, 1e-8, 100, f)
#| code-fold: true
f <- function(x) cos(x)^2 - 2*sin(x)
biseccion(0, 1, 1e-5, 30, f)
#Calculo con R
raiz.a <- uniroot(f, c(0,1))$root
sprintf("%.20f", raiz.a)
round(5* log(10) / log(2))
#| code-fold: true
g <- function(x) -x^3 + x + 1
biseccion(1, 2, 1e-5, 30, g)
#Calculo con R
raiz.b <- uniroot(g, c(1,2))$root
sprintf("%.20f", raiz.b)
#| code-fold: true
#| warning: false
#| message: false
library(ggplot2)
f1 <- function(x) exp(x) + 4*x - 5
f2 <- function(x) x^4 - 2*x - 1
ggplot(data.frame(x = c(-3, 3)), aes(x)) +
stat_function(fun = f1, aes(colour = "f1(x) = exp(x)+4x-5"), size = 1.2) +
stat_function(fun = f2, aes(colour = "f2(x) = x^4-2x-1"), size = 1.2) +
geom_hline(yintercept = 0, colour = "red", linetype = "dashed") +
scale_colour_manual(values = c("blue", "darkgreen")) +
labs(y = "y", colour = "Funciones",
title = "Gráfico de f1 y f2 en [-3,3]") +
theme_minimal()
#| code-fold: true
biseccion(0,1,1e-4,30,f1)
#Calculo con R
raiz.a <- uniroot(f1,c(0,1))$root
sprintf("%.20f", raiz.a)
#| code-fold: true
#Raiz en intervalo [1,2]
biseccion(1,2,1e-4,30,f2)$valor
#Calculo con R
raiz.b.1 <- uniroot(f2,c(1,2))$root
sprintf("%.20f", raiz.b.1)
#Raiz en intervalo [-1,0]
biseccion(-1,0,1e-4,30,f2)$valor
#Calculo con R
raiz.b.2 <- uniroot(f2,c(-1,0))$root
sprintf("%.20f", raiz.b.2)
f1 <- function(x) exp(-x) - x
f1.f <- function(x) exp(-x)
f2 <- function(x) exp(x) - 3*x
f2.f <- function(x) exp(x)/3
punto.fijo(0.55, 1e-5, 18, f1.f)
#Calculo con R
pto.fijo.a <- uniroot(f1, c(0,1))$root
sprintf("%.20f", pto.fijo.a)
punto.fijo(0.6, 1e-5, 30, f2.f)
#Calculo con R
pto.fijo.b <- uniroot(f2, c(0,1))$root
sprintf("%.20f", pto.fijo.b)
steffensen(0.5, 1e-5, 30, f1.f)
#Calculo con R
pto.fijo.a <- uniroot(f1, c(0,1))$root
sprintf("%.20f", pto.fijo.a)
steffensen(0.5, 1e-5, 30, f2.f)
#Calculo con R
pto.fijo.b <- uniroot(f2, c(0,1))$root
sprintf("%.20f", pto.fijo.b)
g1 <- function(x) 3*x^2 - exp(x)
g1.g <- function(x) (sqrt(3)/3) * exp(x/2)
g2 <- function(x) x - cos(x)
g2.g <- function(x) cos(x)
punto.fijo(0.5, 1e-8, 30, g1.g)
#Calculo con R
pto.fijo.a <- uniroot(g1, c(0,1))$root
sprintf("%.20f", pto.fijo.a)
punto.fijo(0.5, 1e-8, 60, g2.g)
#Calculo con R
pto.fijo.b <- uniroot(g2, c(0,1))$root
sprintf("%.20f", pto.fijo.b)
#| code-fold: true
regula_falsi <- function(f, a, b, tol = 1e-6, Nmax = 100) {
if (f(a) * f(b) >= 0) {
stop("No se garantiza una raíz en el intervalo [a, b].")
}
for (i in 1:Nmax) {
fa <- f(a)
fb <- f(b)
p <- (a * fb - b * fa) / (fb - fa)
if (abs(f(p)) < tol) {
cat("Iteraciones:", i, "\n")
return(p)
}
if (f(p) * fa < 0) {
b <- p
} else {
a <- p
}
}
stop("No se alcanzó la tolerancia deseada en el número máximo de iteraciones.")
}
f <- function(x) x^3 - x - 2
raiz <- regula_falsi(f, 1, 2, tol = 1e-6)
print(raiz)
bernstein <- function(n, F, x) {
resultado <- numeric(length(x))
for (i in seq_along(x)) {
xi <- x[i]
suma <- 0
for (k in 0:n) {
coef <- choose(n, k) * (xi^k) * ((1 - xi)^(n - k))
suma <- suma + coef * F(k / n)
}
resultado[i] <- suma
}
return(resultado)
}
# Ejemplo: F(x) = exp(x) en [0,1]
F <- function(x) exp(x)
xs <- seq(0, 1, length.out = 400)
# Aproximación con n = 10
vals <- bernstein(10, F, xs)
# Graficar
plot(xs, F(xs), type = "l", col = "red", lwd = 2,
main = "Aproximación de Bernstein de exp(x) en [0,1]",
ylab = "f(x)", xlab = "x")
lines(xs, vals, col = "blue", lwd = 2)
legend("topleft", legend = c("exp(x)", "Bernstein n=10"),
col = c("red", "blue"), lwd = 2)
# Paquetes necesarios
library(ggplot2)
# Datos de los nodos
x <- c(-2, -1, 0, 1, 2)
y <- c(-1.2, 0.5, 1, 2.8, 3.5)
# Ajuste del polinomio interpolante de grado 4
modelo <- lm(y ~ poly(x, 4, raw = TRUE))
# Datos para graficar el polinomio
x_vals <- seq(min(x) - 0.5, max(x) + 0.5, length.out = 500)
y_vals <- predict(modelo, newdata = data.frame(x = x_vals))
# Crear un data frame con los nodos para etiquetas
df_nodos <- data.frame(x = x, y = y,
etiqueta = paste0("(", x, ", ", y, ")"))
# Gráfico
ggplot() +
geom_line(aes(x = x_vals, y = y_vals), color = "darkred", linewidth = 1.3) +
geom_point(data = df_nodos, aes(x = x, y = y), size = 3, shape = 21, fill = "white") +
geom_text(data = df_nodos, aes(x = x, y = y, label = etiqueta),
vjust = -1.2, size = 3.5) +
labs(
title = "Interpolación polinómica con nodos: (-2,-1.2), (-1,0.5), (0,1), (1,2.8), (2,3.5)",
subtitle = "Polinomio P[n](x) tal que  Pₙ(xᵢ) = yᵢ",
x = "x",
y = "y"
) +
theme_minimal(base_size = 14)
# Paquetes necesarios
library(ggplot2)
# Datos de los nodos
x <- c(-2, -1, 0, 1, 2)
y <- c(-1.2, 0.5, 1, 2.8, 3.5)
# Ajuste del polinomio interpolante de grado 4
modelo <- lm(y ~ poly(x, 4, raw = TRUE))
# Datos para graficar el polinomio
x_vals <- seq(min(x) - 0.5, max(x) + 0.5, length.out = 500)
y_vals <- predict(modelo, newdata = data.frame(x = x_vals))
# Crear un data frame con los nodos para etiquetas
df_nodos <- data.frame(x = x, y = y,
etiqueta = paste0("(", x, ", ", y, ")"))
# Gráfico
ggplot() +
geom_line(aes(x = x_vals, y = y_vals), color = "darkred", linewidth = 1.3) +
geom_point(data = df_nodos, aes(x = x, y = y), size = 3, shape = 21, fill = "white") +
geom_text(data = df_nodos, aes(x = x, y = y, label = etiqueta),
vjust = -1.2, size = 3.5) +
labs(
title = "Interpolación polinómica con nodos: (-2,-1.2), (-1,0.5), (0,1), (1,2.8), (2,3.5)",
subtitle = "Polinomio P[n](x) tal que  Pₙ(xᵢ) = yᵢ",
x = "x",
y = "y"
) +
theme_minimal(base_size = 14)
