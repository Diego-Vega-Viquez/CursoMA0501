# Paso 4: rellenar vectores l, m, z
for (i in 2:(n - 1)) {
l[i] <- 2 * (nodos[i + 1] - nodos[i - 1]) - h[i - 1] * m[i - 1]
m[i] <- h[i] / l[i]
z[i] <- (alfa[i] - h[i - 1] * z[i - 1]) / l[i]
}
# Paso 5: definir valores finales
l[n] <- 1 #creo que esto no hace falta
z[n] <- 0 #esto tampoco
c <- numeric(n)
c[n] <- 0
b <- numeric(n)
d <- numeric(n)
# Paso 6: sustitucion hacia atras
for (j in (n - 1):1) {
c[j] <- z[j] - m[j] * c[j + 1]
b[j] <- (valores[j + 1] - valores[j]) / h[j] - (h[j] / 3) * (c[j + 1] +
2 * c[j])
d[j] <- (c[j + 1] - c[j]) / (3 * h[j])
}
# Paso extra: evaluar la interpolacion en el punto x especificado
## Encontramos los dos nodos que estan prensando al intervalo
indice <- NULL
for (i in 1:(n - 1)) {
if (x >= nodos[i] && x < nodos[i + 1]) {
indice <- i
}
}
if(x == nodos[n]){
indice <- n
}
if (is.null(indice)) {
return("El valor de interpolacion debe estar entre dos nodos")
}
## evaluamos en la funcion asociada
valor <- valores[indice] + b[indice] * (x - nodos[indice]) + c[indice] * (x - nodos[indice])^2 + d[indice] * (x - nodos[indice])^3
return(list(
a = valores,
b = b,
c = c,
d = d,
valor = valor
))
}
#| code-fold: true
# spline.sujeto: funcion que calcula la interpolacion por splines a partir de unos nodos y sus valores
# Retorna los valores de los coeficientes a, b, c, d de cada una de las n-1 ecuaciones generadas
spline.sujeto <- function(nodos, valores, derivadas, x) {
# Note que los valores de a corresponden a los valores de los nodos en la funcion, por lo que cuando aparezca el vector "valores" se debe entender que equivale al vector "a"
stopifnot(length(derivadas) == 2)
n <- length(nodos)
h <- numeric(n - 1)
alfa <- numeric(n)
# Paso 1 y 2: definir los h's y alfas
for (i in 1:(n - 1)) {
h[i] <- nodos[i + 1] - nodos[i]
if (i != 1) {
alfa[i] <- (3 / h[i]) * (valores[i + 1] - valores[i]) - (3 / h[i - 1]) *
(valores[i] - valores[i - 1])
}
}
alfa[1] <- 3 * ((valores[2] - valores[1]) / h[1] - derivadas[1])
alfa[n] <- 3 * (derivadas[2] - (valores[n] - valores[n - 1]) / h[n - 1])
#Paso 3: definir valores iniciales de l, m, y z
l <- numeric(n) # creo que el tamano de esto puede ser n-1
l[1] <- 2 * h[1]
m <- numeric(n - 1)
m[1] <- 1 / 2
z <- numeric(n) # creo que el tamano de esto puede ser n-1
z[1] <- alfa[1] / l[1]
# Paso 4: rellenar vectores l, m, z
for (i in 2:(n - 1)) {
l[i] <- 2 * (nodos[i + 1] - nodos[i - 1]) - h[i - 1] * m[i - 1]
m[i] <- h[i] / l[i]
z[i] <- (alfa[i] - h[i - 1] * z[i - 1]) / l[i]
}
# Paso 5: definir valores finales
l[n] <- h[n - 1] * (2 - m[n - 1])
z[n] <- (alfa[n] - h[n - 1] * z[n - 1]) / l[n]
c <- numeric(n)
c[n] <- z[n]
b <- numeric(n)
d <- numeric(n)
# Paso 6: sustitucion hacia atras
for (j in (n - 1):1) {
c[j] <- z[j] - m[j] * c[j + 1]
b[j] <- (valores[j + 1] - valores[j]) / h[j] - (h[j] / 3) * (c[j + 1] + 2 * c[j])
d[j] <- (c[j + 1] - c[j]) / (3 * h[j])
}
# Paso extra: evaluar la interpolacion en el punto x especificado
## Encontramos los dos nodos que estan prensando al intervalo
indice <- NULL
for (i in 1:(n - 1)) {
if (x >= nodos[i] && x < nodos[i + 1]) {
indice <- i
}
}
if (x == nodos[n]) {
indice <- n
}
if (is.null(indice)) {
return("El valor de interpolacion debe estar entre dos nodos")
}
## evaluamos en la funcion asociada
valor <- valores[indice] + b[indice] * (x - nodos[indice]) + c[indice] * (x - nodos[indice])^2 + d[indice] * (x - nodos[indice])^3
return(list(
a = valores,
b = b,
c = c,
d = d,
valor = valor
))
}
#| message: false
#| warning: false
#| code-fold: true
library(tidyverse)
graficar.polinomio <- function(nodos,
a,
b,
metodo,
f = NULL,
valores = NULL,
df = NULL,
derivadas = NULL,
derivadas.clamped = NULL) {
stopifnot(is.numeric(nodos), length(nodos) >= 2)
# Validación: exactamente uno de f o valores
if (is.null(f) == is.null(valores)) {
stop("Debe proveer exactamente uno: 'f' (función) o 'valores' (numérico).")
}
# Valores en nodos
if (!is.null(f)) {
stopifnot(is.function(f))
valores_nodos <- f(nodos)
} else {
stopifnot(is.numeric(valores), length(valores) == length(nodos))
valores_nodos <- valores
}
# ---- Derivadas en nodos (si aplica) ----
derivadas_nodos <- NULL
# Si llegan ambos, priorizamos 'derivadas' y avisamos
if (!is.null(df) && !is.null(derivadas)) {
warning("Se pasaron 'df' y 'derivadas'; se usará 'derivadas'.")
}
if (!is.null(derivadas)) {
stopifnot(is.numeric(derivadas), length(derivadas) == length(nodos))
derivadas_nodos <- derivadas
} else if (!is.null(df)) {
if (is.function(df)) {
derivadas_nodos <- df(nodos)
} else if (is.numeric(df)) {
stopifnot(length(df) == length(nodos))
derivadas_nodos <- df
} else {
stop("`df` debe ser función o vector numérico de derivadas en los nodos.")
}
}
# Wrapper vectorizado para el método (con o sin derivadas)
if (!is.null(derivadas_nodos)) {
H <- function(x)
vapply(x, function(xx)
metodo(nodos, valores_nodos, derivadas_nodos, xx)$valor, numeric(1))
} else {
if (is.null(derivadas.clamped)) {
H <- function(x)
vapply(x, function(xx)
metodo(nodos, valores_nodos, xx)$valor, numeric(1))
} else {
H <- function(x)
vapply(x, function(xx)
spline.sujeto(nodos, valores_nodos, derivadas.clamped, xx)$valor, numeric(1))
}
}
# Malla y data frames
xi <- seq(a, b, length.out = 400)
df_plot <- data.frame(
x  = xi,
Hx = H(xi),
fx = if (!is.null(f)) f(xi) else NA_real_
)
df_nodos <- data.frame(x = nodos, y = valores_nodos)
# Gráfico
p <- ggplot(df_plot, aes(x = x))
if (!is.null(f)) {
p <- p +
geom_line(aes(y = fx, color = "Original"), linewidth = 1) +
geom_line(aes(y = Hx, color = "Interpolación"),
linewidth = 1, linetype = "dashed") +
scale_color_manual(values = c("Original" = "blue", "Interpolación" = "red"))
} else {
p <- p +
geom_line(aes(y = Hx, color = "Interpolación"), linewidth = 1) +
scale_color_manual(values = c("Interpolación" = "red"))
}
p +
geom_point(data = df_nodos, aes(x = x, y = y),
shape = 21, size = 3, fill = "white") +
labs(title = paste0("Interpolación por ", deparse(substitute(metodo))),
y = "Valor", color = "Serie") +
theme_minimal(base_size = 14)
}
#| code-fold: true
f <- function(x) log(x)
df <- function(x) 1/x
nodos <- c(0.1, 0.5, 1, 1.5, 2)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], neville, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], lagrange.newton, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], hermite.newton, f = f, df = df)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], spline.natural, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], spline.sujeto, f = f, derivadas.clamped = c(df(nodos[1]), df(nodos[length(nodos)])))
neville(c(0.2, 0.4, 0.6, 0.8, 1.0), c(0.9798652, 0.9177710, 0.8080348, 0.6386093, 0.3843735), 0.5)
f <- function(x) 3*x*exp(x) - exp(2*x)
nodos <- c(1, 1.05, 1.07)
valores <- f(nodos)
valor.a <- neville(nodos, valores, 1.03)$valor
valor.a
nodos <- c(nodos, 1.04)
valores <- f(nodos)
valor.b <- neville(nodos, valores, 1.03)$valor
valor.b
error.real.a <- abs(valor.a-f(1.03))
error.real.a
error.real.b <- abs(valor.b-f(1.03))
error.real.b
library(Deriv)
f3 <- Deriv(~ 3*x*exp(x) - exp(2*x), x = quote(x), nderiv = 3)
error.real.a <- abs(valor.a-f(1.03))
error.real.a
error.real.b <- abs(valor.b-f(1.03))
error.real.b
library(Deriv)
f3 <- Deriv(~ 3*x*exp(x) - exp(2*x), x = quote(x), nderiv = 3)
error.real.a <- abs(valor.a-f(1.03))
error.real.a
error.real.b <- abs(valor.b-f(1.03))
error.real.b
library(Deriv)
library(Deriv)
f_expr <- function(x) 3*x*exp(x) - exp(2*x)
f3 <- Deriv(f_expr, x = "x", nderiv = 3)
f4 <- Deriv(f_expr, x = "x", nderiv = 4)
intervalo <- seq(1, 1.07, length.out = 1000)
max_f3 <- max(abs(sapply(intervalo, f3)))
max_f4 <- max(abs(sapply(intervalo, f4)))
producto.a <- prod(abs(1.03 - c(1, 1.05, 1.07)))
producto.b <- prod(abs(1.03 - c(1, 1.05, 1.07, 1.04)))
# Cotas teóricas del error
error.teorico.a <- max_f3 / factorial(3) * producto.a
error.teorico.b <- max_f4 / factorial(4) * producto.b
error.teorico.a
error.teorico.b
error.real.a <- abs(valor.a-f(1.03))
error.real.a
error.real.b <- abs(valor.b-f(1.03))
error.real.b
library(Deriv)
f3 <- Deriv(f, x = "x", nderiv = 3)
f4 <- Deriv(f, x = "x", nderiv = 4)
intervalo <- seq(1, 1.07, length.out = 1000)
max_f3 <- max(abs(sapply(intervalo, f3)))
max_f4 <- max(abs(sapply(intervalo, f4)))
producto.a <- prod(abs(1.03 - c(1, 1.05, 1.07)))
producto.b <- prod(abs(1.03 - c(1, 1.05, 1.07, 1.04)))
# Cotas teóricas del error
error.teorico.a <- max_f3 / factorial(3) * producto.a
error.teorico.b <- max_f4 / factorial(4) * producto.b
error.teorico.a
error.teorico.b
#| eval: false
# Algoritmo Trapecio Extendido con límites en y dependientes de x
trapecio_doble_variable <- function(f, a, b, yinf, ysup, nx = 200, ny = 200) {
hx <- (b - a) / nx
suma_total <- 0
for (i in 0:nx) {
x <- a + i * hx
ly <- yinf(x); uy <- ysup(x)
hy <- (uy - ly) / ny
for (j in 0:ny) {
y <- ly + j * hy
peso <- 1
if (i == 0 || i == nx) peso <- peso / 2
if (j == 0 || j == ny) peso <- peso / 2
suma_total <- suma_total + peso * f(x, y)
}
}
hx * ( (ysup((a+b)/2) - yinf((a+b)/2)) / ny ) * suma_total
}
## ------------------------------
## Ejercicio 9 (Área)
## Región: y = 4x - x^2 (0<=x<=1) y y = -3x+6 (1<=x<=2), con y>=0
f_area <- function(x, y) 1
A1 <- trapecio_doble_variable(f_area,
a = 0, b = 1,
yinf = function(x) 0,
ysup = function(x) 4*x - x^2,
nx = 300, ny = 300)
A2 <- trapecio_doble_variable(f_area,
a = 1, b = 2,
yinf = function(x) 0,
ysup = function(x) -3*x + 6,
nx = 300, ny = 300)
A_num <- A1 + A2
A_exacto <- 19/6
cat(sprintf("Área (num): %.8f   |   Área (exacta): %.8f   |   Error: %.2e\n",
A_num, A_exacto, A_num - A_exacto))
## ------------------------------
## Ejercicio 10 (Volumen)
## z = 4 - x^2 - 2y^2 sobre x^2 + 2y^2 <= 4  (z>=0)
f_vol <- function(x, y) 4 - x^2 - 2*y^2
V_num <- trapecio_doble_variable(f_vol,
a = -sqrt(2), b =  sqrt(2),
yinf = function(x) -sqrt((4 - x^2)/2),
ysup = function(x)  sqrt((4 - x^2)/2),
nx = 300, ny = 300)
V_exacto <- 4*pi*sqrt(2)
cat(sprintf("Volumen (num): %.8f   |   Volumen (exacto): %.8f   |   Error: %.2e\n",
V_num, V_exacto, V_num - V_exacto))
#| code-fold: true
# Método de Euler Modificado (RK2)
euler_modificado <- function(f, a, b, y0, N) {
h <- (b - a) / N
t <- numeric(N + 1)
y <- numeric(N + 1)
t[1] <- a
y[1] <- y0
for (i in 1:N) {
k1 <- f(t[i], y[i])
k2 <- f(t[i] + h/2, y[i] + (h/2) * k1)
y[i + 1] <- y[i] + h * k2
t[i + 1] <- t[i] + h
}
data.frame(t = t, y = y)
}
# EDO 1: y' = -2t y^2
f1 <- function(t, y) {
-2 * t * y^2
}
# EDO 2: y' = y + cos(t)
f2 <- function(t, y) {
y + cos(t)
}
# EDO 3: y' = - (x sqrt(1 - y^2)) / (y sqrt(1 - x^2))
f3 <- function(x, y) {
# Comprobar que x e y son numéricos válidos
if (is.na(x) || is.na(y)) return(0)
if (abs(x) >= 1 || abs(y) >= 1) return(0)  # usamos 0 en lugar de NA para mantener la simulación estable
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
# Parámetros comunes
a <- 0
b <- 1
N <- 100
# Resolver las tres EDOs
sol1 <- euler_modificado(f1, a, b, y0 = 1, N)
sol2 <- euler_modificado(f2, a, b, y0 = 0.5, N)
sol3 <- euler_modificado(f3, a, b, y0 = 1, N)
# Graficar resultados
par(mfrow = c(1, 3))  # 3 gráficos lado a lado
plot(sol1$t, sol1$y, type = "l", col = "blue", lwd = 2,
main = "EDO 1: y' = -2ty²", xlab = "t", ylab = "y(t)")
grid()
plot(sol2$t, sol2$y, type = "l", col = "darkgreen", lwd = 2,
main = "EDO 2: y' = y + cos(t)", xlab = "t", ylab = "y(t)")
grid()
plot(sol3$t, sol3$y, type = "l", col = "red", lwd = 2,
main = "EDO 3: y' racional no lineal", xlab = "x", ylab = "y(x)")
grid()
#| code-fold: true
# Función f(t, y) del problema
f <- function(t, y) {
(2 / t) * y + t^2 * exp(t)
}
# Solución exacta
y_exacta <- function(t) {
t^2 * (exp(t) - exp(1))
}
# Método de Euler Modificado (RK2)
euler_modificado <- function(f, a, b, y0, N) {
h <- (b - a) / N
t <- numeric(N + 1)
y <- numeric(N + 1)
t[1] <- a
y[1] <- y0
for (i in 1:N) {
k1 <- f(t[i], y[i])
k2 <- f(t[i] + h/2, y[i] + (h/2) * k1)
y[i + 1] <- y[i] + h * k2
t[i + 1] <- t[i] + h
}
data.frame(t = t, y_aprox = y, y_real = y_exacta(t), error = abs(y_exacta(t) - y))
}
#| code-fold: true
f1 <- function(t, y) {
-2 * t * y^2
}
# Parámetros
a1 <- 0; b1 <- 1; y01 <- 1; N <- 20
res1 <- euler_modificado(f1, a1, b1, y01, N)
# Solución exacta: y(t) = 1 / (1 + t^2)
y1_exacta <- function(t) {
1 / (1 + t^2)
}
# Graficar
plot(res1$t, y1_exacta(res1$t), type = "l", col = "blue", lwd = 2,
main = "Problema 1: Euler Modificado vs Solución Exacta", xlab = "t", ylab = "y(t)")
lines(res1$t, res1$y, col = "red", lty = 2, lwd = 2)
legend("topright", legend = c("Exacta", "Euler Modificado"),
col = c("blue", "red"), lty = c(1,2), lwd = 2)
#| code-fold: true
# Método de Euler Modificado (RK2)
euler_modificado <- function(f, a, b, y0, N) {
h <- (b - a) / N
t <- numeric(N + 1)
y <- numeric(N + 1)
t[1] <- a
y[1] <- y0
for (i in 1:N) {
k1 <- f(t[i], y[i])
k2 <- f(t[i] + h/2, y[i] + (h/2) * k1)
y[i + 1] <- y[i] + h * k2
t[i + 1] <- t[i] + h
}
data.frame(t = t, y = y)
}
#| code-fold: true
f1 <- function(t, y) {
-2 * t * y^2
}
# Parámetros
a1 <- 0; b1 <- 1; y01 <- 1; N <- 20
res1 <- euler_modificado(f1, a1, b1, y01, N)
# Solución exacta: y(t) = 1 / (1 + t^2)
y1_exacta <- function(t) {
1 / (1 + t^2)
}
# Graficar
plot(res1$t, y1_exacta(res1$t), type = "l", col = "blue", lwd = 2,
main = "Problema 1: Euler Modificado vs Solución Exacta", xlab = "t", ylab = "y(t)")
lines(res1$t, res1$y, col = "red", lty = 2, lwd = 2)
legend("topright", legend = c("Exacta", "Euler Modificado"),
col = c("blue", "red"), lty = c(1,2), lwd = 2)
#| code-fold: true
f2 <- function(t, y) {
cos(t) + y
}
# Parámetros
a2 <- 0; b2 <- 1; y02 <- 0.5
res2 <- euler_modificado(f2, a2, b2, y02, N)
# No hay solución exacta elemental, graficamos solo la aproximada
plot(res2$t, res2$y, type = "l", col = "darkgreen", lwd = 2,
main = "Problema 2: Euler Modificado", xlab = "t", ylab = "y(t)")
#| code-fold: true
f3 <- function(x, y) {
# Manejo seguro para evitar división por cero o raíz negativa
if (abs(x) >= 1 || abs(y) >= 1 || y == 0) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0; b3 <- 1; y03 <- 1
res3 <- euler_modificado(f3, a3, b3, y03, N)
#| code-fold: true
f3 <- function(x, y) {
# Manejo seguro para evitar división por cero o raíz negativa
if (abs(x) >= 1 || abs(y) >= 1 || y == 0) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0; b3 <- 1; y03 <- 1
res3 <- euler_modificado(f3, a3, b3, y03, N)
#| code-fold: true
f3 <- function(x, y) {
if (is.na(x) || is.na(y) || is.nan(x) || is.nan(y)) return(NA)
if ((1 - x^2) <= 0 || (1 - y^2) <= 0 || abs(y) < 1e-8) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0; b3 <- 1; y03 <- 0.9  # <- cambiado
res3 <- euler_modificado(f3, a3, b3, y03, N)
validos <- !is.na(res3$y)
plot(res3$t[validos], res3$y[validos], type = "l", col = "purple", lwd = 2,
main = "Problema 3: Euler Modificado", xlab = "x", ylab = "y(x)")
#| code-fold: true
# Método de Runge-Kutta de tercer orden (RK3)
runge_kutta_3 <- function(f, a, b, y0, N) {
h <- (b - a) / N
t <- numeric(N + 1)
y <- numeric(N + 1)
t[1] <- a
y[1] <- y0
for (i in 1:N) {
k1 <- f(t[i], y[i])
k2 <- f(t[i] + h/2, y[i] + h/2 * k1)
k3 <- f(t[i] + h, y[i] - h * k1 + 2 * h * k2)
y[i + 1] <- y[i] + h / 6 * (k1 + 4 * k2 + k3)
t[i + 1] <- t[i] + h
}
data.frame(t = t, y = y)
}
# Definir la ecuación diferencial (ejemplo: y' = y + t)
f2 <- function(t, y) {
y + t
}
# Parámetros del problema
a2 <- 0  # valor inicial de t
b2 <- 1  # valor final de t
y02 <- 0.5  # condición inicial y(0) = 0.5
N <- 20  # número de pasos
# Ejecutar el método
res2 <- runge_kutta_3(f2, a2, b2, y02, N)
# Graficar solución aproximada
plot(res2$t, res2$y, type = "l", col = "green", lwd = 2,
main = "Problema 2: Runge-Kutta de 3er Orden",
xlab = "t", ylab = "y(t)")
Esto prueba que
