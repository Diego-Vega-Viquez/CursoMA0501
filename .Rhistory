vapply(
x,
function(xx)
metodo1(nodos1, valores_nodos_1, xx)$valor,
numeric(1)
)
}
if (tiene.segundo) {
H2 <- function(x) {
vapply(
x,
function(xx)
metodo2(nodos2, valores_nodos_2, xx)$valor,
numeric(1)
)
}
} else {
H2 <- NULL
}
xi <- seq(a, b, length.out = 400)
fx1.col <- if (!is.null(f1)) f1(xi) else NA_real_
if (tiene.segundo) {
fx2.col <- if (!is.null(f2)) f2(xi) else NA_real_
} else {
fx2.col <- NA_real_
}
fx.ref.col <- if (!is.null(f.referencia)) {
stopifnot(is.function(f.referencia))
f.referencia(xi)
} else {
NA_real_
}
df_plot <- data.frame(
x        = xi,
H1x      = H1(xi),
H2x      = if (tiene.segundo) H2(xi) else NA_real_,
fx1      = fx1.col,
fx2      = fx2.col,
fx.ref   = fx.ref.col
)
df_nodos_1 <- data.frame(x = nodos1, y = valores_nodos_1)
if (tiene.segundo) {
df_nodos_2 <- data.frame(x = nodos2, y = valores_nodos_2)
}
p <- ggplot(df_plot, aes(x = x))
if (!is.null(f.referencia)) {
p <- p +
geom_line(
aes(y = fx.ref,
color = "Referencia",
linetype = "Referencia"),
linewidth = 1
)
}
if (!is.null(f1)) {
p <- p +
geom_line(
aes(y = fx1,
color = "Original 1",
linetype = "Original 1"),
linewidth = 1
)
}
if (tiene.segundo && !is.null(f2)) {
p <- p +
geom_line(
aes(y = fx2,
color = "Original 2",
linetype = "Original 2"),
linewidth = 1
)
}
p <- p +
geom_line(
aes(y = H1x,
color = "Interpolación 1",
linetype = "Interpolación 1"),
linewidth = 1
)
if (tiene.segundo) {
p <- p +
geom_line(
aes(y = H2x,
color = "Interpolación 2",
linetype = "Interpolación 2"),
linewidth = 1
)
}
p <- p +
geom_point(
data = df_nodos_1,
aes(x = x, y = y, fill = "Nodos 1"),
shape = 21,
size = 3,
stroke = .6,
color = "black"
)
if (tiene.segundo) {
p <- p +
geom_point(
data = df_nodos_2,
aes(x = x, y = y, fill = "Nodos 2"),
shape = 21,
size = 3,
stroke = .6,
color = "black"
)
}
p <- p +
scale_color_manual(
values = c(
"Original 1"        = "blue",
"Original 2"        = "darkgreen",
"Interpolación 1"   = "red",
"Interpolación 2"   = "purple",
"Referencia"        = "orange"
),
name = "Serie"
) +
scale_linetype_manual(
values = c(
"Original 1"        = "solid",
"Original 2"        = "solid",
"Interpolación 1"   = "dashed",
"Interpolación 2"   = "dashed",
"Referencia"        = "solid"
),
guide = "none"
) +
scale_fill_manual(
values = c(
"Nodos 1" = "white",
"Nodos 2" = "grey70"
),
name = "Nodos"
) +
labs(
title = if (tiene.segundo) {
paste0(
"Interpolación 1: ",
deparse(substitute(metodo1)),
" | Interpolación 2: ",
deparse(substitute(metodo2))
)
} else {
paste0(
"Interpolación por ",
deparse(substitute(metodo1))
)
},
y = "Valor",
x = "x"
) +
theme_minimal(base_size = 14)
p
}
#| code-fold: true
metodo.euler <- function(a, b, N, alfa, f){
h <- (b - a) / N
t <- a
w <- alfa
T <- numeric(N + 1)
W <- numeric(N + 1)
T[1] <- t
W[1] <- w
for (i in 2:(N+1)) {
W[i] <- W[i-1] + h*f(T[i-1],W[i-1])
T[i] <- t + (i - 1)*h
}
tabla <- data.frame(t = T, w = W)
return(list(t = T, w = W, tabla = tabla))
}
#| code-fold: true
metodo.euler.predictor.corrector <- function(a, b, N, alfa, f){
h <- (b - a) / N
t <- a
w <- alfa
T <- numeric(N + 1)
W <- numeric(N + 1)
T[1] <- t
W[1] <- w
for (i in 2:(N+1)) {
W[i] <- W[i-1] + h*f(T[i-1],W[i-1]) #predictor
T[i] <- T[i - 1] + h
W[i] <- W[i-1] + (h/2)*(f(T[i-1], W[i-1]) + f(T[i], W[i])) #corrector
}
tabla <- data.frame(t = T, w = W)
return(list(t = T, w = W, tabla = tabla))
}
#| code-fold: true
runge.kutta.punto.medio <- function(a, b, N, alfa, f){
h <- (b - a) / N
t <- a
w <- alfa
T <- numeric(N + 1)
W <- numeric(N + 1)
T[1] <- t
W[1] <- w
for (i in 2:(N+1)) {
W[i] <- W[i-1] + h*f(T[i-1] + (h/2),W[i-1] + (h/2)*f(T[i-1], W[i-1])) #predictor
T[i] <- T[i - 1] + h
}
tabla <- data.frame(t = T, w = W)
return(list(t = T, w = W, tabla = tabla))
}
#| code-fold: true
runge.kutta.cuarto.orden <- function(a, b, N, alfa, f){
h <- (b - a) / N
t <- a
w <- alfa
T <- numeric(N + 1)
W <- numeric(N + 1)
T[1] <- t
W[1] <- w
for (i in 2:(N+1)) {
k1 <- h*f(T[i-1], W[i-1])
k2 <- h*f(T[i-1] + h/2, W[i-1] + k1/2)
k3 <- h*f(T[i-1] + h/2, W[i-1] + k2/2)
k4 <- h*f(T[i-1] + h, W[i-1] + k3)
W[i] <- W[i-1] + (1/6)*(k1 + 2*k2 + 2*k3 + k4)
T[i] <- T[i - 1] + h
}
tabla <- data.frame(t = T, w = W)
return(list(t = T, w = W, tabla = tabla))
}
library(deSolve)
#| code-fold: true
p1.euler <- metodo.euler(0, 1, 10, 1, function(t, y) -2*t*y^2)
p1.euler.pc <- metodo.euler.predictor.corrector(0, 1, 10, 1, function(t, y) -2*t*y^2)
p1.rkpm <- runge.kutta.punto.medio(0, 1, 10, 1, function(t, y) -2*t*y^2)
p1.rk4o <- runge.kutta.cuarto.orden(0, 1, 10, 1, function(t, y) -2*t*y^2)
data.frame(nodos = p1.euler$t, euler = p1.euler$w, euler.pred.corrector = p1.euler.pc$w, runge.kutta.punto.medio = p1.rkpm$w, runge.kutta.cuarto.orden = p1.rk4o$w)
#| code-fold: true
p2.euler <- metodo.euler(0, 1, 10, 1/2, function(x, y) cos(x) + y)
p2.euler.pc <- metodo.euler.predictor.corrector(0, 1, 10, 1/2, function(x, y) cos(x) + y)
p2.rkpm <- runge.kutta.punto.medio(0, 1, 10, 1/2, function(x, y) cos(x) + y)
p2.rk4o <- runge.kutta.cuarto.orden(0, 1, 10, 1/2, function(x, y) cos(x) + y)
data.frame(nodos = p2.euler$t, euler = p2.euler$w, euler.pred.corrector = p2.euler.pc$w, runge.kutta.punto.medio = p2.rkpm$w, runge.kutta.cuarto.orden = p2.rk4o$w)
#| code-fold: true
p3.euler <- metodo.euler(0, 1, 10, 1, function(t, y)- ( t * sqrt(1 - y^2) ) / ( y * sqrt(1 - t^2) ))
p3.euler.pc <- metodo.euler.predictor.corrector(0, 1, 10, 1, function(t, y)- ( t * sqrt(1 - y^2) ) / ( y * sqrt(1 - t^2) ))
p3.rkpm <- runge.kutta.punto.medio(0, 1, 10, 1, function(t, y)- ( t * sqrt(1 - y^2) ) / ( y * sqrt(1 - t^2) ))
p3.rk4o <- runge.kutta.cuarto.orden(0, 1, 10, 1, function(t, y)- ( t * sqrt(1 - y^2) ) / ( y * sqrt(1 - t^2) ))
data.frame(nodos = p3.euler$t, euler = p3.euler$w, euler.pred.corrector = p3.euler.pc$w, runge.kutta.punto.medio = p3.rkpm$w, runge.kutta.cuarto.orden = p3.rk4o$w)
#| code-fold: true
edo <- function(t, y, parms) {
dydt <- -2 * t * y^2
list(dydt)
}
y0 <- 1
tiempos <- seq(0, 1, by = 0.1)
sol <- ode(y = y0, times = tiempos, func = edo, parms = NULL)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p1.euler$t, valores2 = p1.euler$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p1.euler.pc$t, valores2 = p1.euler.pc$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p1.rkpm$t, valores2 = p1.rkpm$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p1.rk4o$t, valores2 = p1.rk4o$w)
#| code-fold: true
edo <- function(t, y, parms) {
dydt <- cos(t) + y
list(dydt)
}
y0 <- 1/2
tiempos <- seq(0, 1, by = 0.1)
sol <- ode(y = y0, times = tiempos, func = edo, parms = NULL)
#| code-fold: true
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p2.euler$t, valores2 = p2.euler$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p2.euler.pc$t, valores2 = p2.euler.pc$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p2.rkpm$t, valores2 = p2.rkpm$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p2.rk4o$t, valores2 = p2.rk4o$w)
#| code-fold: true
edo <- function(t, y, parms) {
dydt <- - ( t * sqrt(1 - y^2) ) / ( y * sqrt(1 - t^2) )
list(dydt)
}
y0 <- 1
tiempos <- seq(0, 0.999, by = 0.1)
sol <- ode(y = y0,
times = tiempos,
func = edo,
parms = NULL)
sol
#| code-fold: true
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p3.euler$t, valores2 = p3.euler$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p3.euler.pc$t, valores2 = p3.euler.pc$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p3.rkpm$t, valores2 = p3.rkpm$w)
graficar.polinomio(sol[,1], 0, 1, neville, valores1 = sol[,2], nodos2 =  p3.rk4o$t, valores2 = p3.rk4o$w)
#| code-fold: true
# Método de Euler Modificado (RK2)
euler_modificado <- function(f, a, b, y0, N) {
h <- (b - a) / N
t <- numeric(N + 1)
y <- numeric(N + 1)
t[1] <- a
y[1] <- y0
for (i in 1:N) {
k1 <- f(t[i], y[i])
k2 <- f(t[i] + h/2, y[i] + (h/2) * k1)
y[i + 1] <- y[i] + h * k2
t[i + 1] <- t[i] + h
}
data.frame(t = t, y = y)
}
#| code-fold: true
f1 <- function(t, y) {
-2 * t * y^2
}
# Parámetros
a1 <- 0; b1 <- 1; y01 <- 1; N <- 20
res1 <- euler_modificado(f1, a1, b1, y01, N)
# Solución exacta: y(t) = 1 / (1 + t^2)
y1_exacta <- function(t) {
1 / (1 + t^2)
}
# Graficar
plot(res1$t, y1_exacta(res1$t), type = "l", col = "blue", lwd = 2,
main = "Problema 1: Euler Modificado vs Solución Exacta", xlab = "t", ylab = "y(t)")
lines(res1$t, res1$y, col = "red", lty = 2, lwd = 2)
legend("topright", legend = c("Exacta", "Euler Modificado"),
col = c("blue", "red"), lty = c(1,2), lwd = 2)
#| code-fold: true
f2 <- function(t, y) {
cos(t) + y
}
# Parámetros
a2 <- 0; b2 <- 1; y02 <- 0.5
res2 <- euler_modificado(f2, a2, b2, y02, N)
# No hay solución exacta elemental, graficamos solo la aproximada
plot(res2$t, res2$y, type = "l", col = "darkgreen", lwd = 2,
main = "Problema 2: Euler Modificado", xlab = "t", ylab = "y(t)")
#| code-fold: true
f3 <- function(x, y) {
if (is.na(x) || is.na(y) || is.nan(x) || is.nan(y)) return(NA)
if ((1 - x^2) <= 0 || (1 - y^2) <= 0 || abs(y) < 1e-8) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0; b3 <- 1; y03 <- 0.9  # <- cambiado
res3 <- euler_modificado(f3, a3, b3, y03, N)
validos <- !is.na(res3$y)
plot(res3$t[validos], res3$y[validos], type = "l", col = "purple", lwd = 2,
main = "Problema 3: Euler Modificado", xlab = "x", ylab = "y(x)")
#| code-fold: true
tercer.orden.huen <- function(a, b, N, alfa, f){
h <- (b - a) / N
t <- a
w <- alfa
T <- numeric(N + 1)
W <- numeric(N + 1)
T[1] <- t
W[1] <- w
for (i in 2:(N+1)) {
k1 <- f(T[i-1], W[i-1])
k2 <- f(T[i-1] + h/3, W[i-1] + k1*(h/3))
k3 <- f(T[i-1] + (2/3)*h, W[i-1] + (2*h/3)*k2)
W[i] <- W[i-1] + (h/4)*(k1 + 3*k3)
T[i] <- T[i - 1] + h
}
tabla <- data.frame(t = T, w = W)
return(list(t = T, w = W, tabla = tabla))
}
#| code-fold: true
p1 <- tercer.orden.huen(0, 1, 10, 1, function(x, y) -2*x*y^2)
p1$tabla
graficar.polinomio(p1$t, 0, 1, neville, valores1 = p1$w, f.referencia = function(t) 1 / (1 + t^2))
#| code-fold: true
p2 <- tercer.orden.huen(0, 1, 10, 1/2, function(x, y) cos(x) + y)
p1$tabla
graficar.polinomio(p1$t, 0, 1, neville, valores1 = p1$w, f.referencia = function(t) 1 / (1 + t^2))
#| code-fold: true
p3 <- tercer.orden.huen(0, 1, 10, 1, function(t, y)- ( t * sqrt(1 - y^2) ) / ( y * sqrt(1 - t^2) ))
p3$tabla
graficar.polinomio(p3$t, 0, 1, neville, valores1 = p3$w, f.referencia = function(x) 1)
#| code-fold: true
# Método de Euler Modificado (RK2)
runge_kutta_3 <- function(f, a, b, y0, N) {
h <- (b - a) / N
t <- numeric(N + 1)
y <- numeric(N + 1)
t[1] <- a
y[1] <- y0
for (i in 1:N) {
k1 <- f(t[i], y[i])
k2 <- f(t[i] + h/2, y[i] + h/2 * k1)
k3 <- f(t[i] + h, y[i] - h * k1 + 2 * h * k2)
y[i + 1] <- y[i] + h / 6 * (k1 + 4 * k2 + k3)
t[i + 1] <- t[i] + h
}
data.frame(t = t, y = y)
}
#| code-fold: true
# Función del problema 1
f1 <- function(t, y) {
-2 * t * y^2
}
# Parámetros
a1 <- 0; b1 <- 1; y01 <- 1; N <- 20
res1 <- runge_kutta_3(f1, a1, b1, y01, N)
# Solución exacta: y(t) = 1 / (1 + t^2)
y1_exacta <- function(t) {
1 / (1 + t^2)
}
# Graficar
plot(res1$t, y1_exacta(res1$t), type = "l", col = "blue", lwd = 2,
main = "Problema 1: Runge-Kutta de 3er Orden vs Solución Exacta", xlab = "t", ylab = "y(t)")
lines(res1$t, res1$y, col = "red", lty = 2, lwd = 2)
legend("topright", legend = c("Exacta", "Runge-Kutta 3er Orden"),
col = c("blue", "red"), lty = c(1,2), lwd = 2)
#| code-fold: true
# Función del problema 2
f2 <- function(t, y) {
cos(t) + y
}
# Parámetros
a2 <- 0; b2 <- 1; y02 <- 0.5
res2 <- runge_kutta_3(f2, a2, b2, y02, N)
# No hay solución exacta elemental, graficamos solo la aproximada
plot(res2$t, res2$y, type = "l", col = "darkgreen", lwd = 2,
main = "Problema 2: Runge-Kutta de 3er Orden", xlab = "t", ylab = "y(t)")
#| code-fold: true
f3 <- function(x, y) {
if (is.na(x) || is.na(y) || is.nan(x) || is.nan(y)) return(NA)
if ((1 - x^2) <= 0 || (1 - y^2) <= 0 || abs(y) < 1e-8) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0; b3 <- 1; y03 <- 0.9  # <- cambiado
res3 <- euler_modificado(f3, a3, b3, y03, N)
validos <- !is.na(res3$y)
plot(res3$t[validos], res3$y[validos], type = "l", col = "purple", lwd = 2,
main = "Problema 3: Euler Modificado", xlab = "x", ylab = "y(x)")
#| code-fold: true
f3 <- function(x, y) {
if (is.na(x) || is.na(y) || is.nan(x) || is.nan(y)) return(NA)
if ((1 - x^2) <= 0 || (1 - y^2) <= 0 || abs(y) < 1e-8) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0
b3 <- 1
y03 <- 1
N <- 1000
res3 <- euler_modificado(f3, a3, b3, y03, N)
validos <- !is.na(res3$y)
plot(res3$t[validos], res3$y[validos], type = "l", col = "purple", lwd = 2,
main = "Problema 3: Euler Modificado", xlab = "x", ylab = "y(x)")
#| code-fold: true
f3 <- function(x, y) {
if (is.na(x) || is.na(y) || is.nan(x) || is.nan(y)) return(NA)
if ((1 - x^2) <= 0 || (1 - y^2) <= 0 || abs(y) < 1e-8) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0
b3 <- 1
y03 <- 1
N <- 1000
res3 <- euler_modificado(f3, a3, b3, y03, N)
validos <- !is.na(res3$y)
plot(res3$t[validos], res3$y[validos], type = "l", col = "purple", lwd = 2,
main = "Problema 3: Euler Modificado (condición correcta)",
xlab = "x", ylab = "y(x)")
res3
#| code-fold: true
# Función del problema (correspondiente a la ecuación de la imagen)
f3 <- function(x, y) {
if (is.na(x) || is.na(y) || is.nan(x) || is.nan(y)) return(NA)
if ((1 - x^2) < 0 || (1 - y^2) < 0 || abs(y) < 1e-8) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
# Parámetros
a3 <- 0
b3 <- 1
y03 <- 1
N <- 100
# Resolver con Runge-Kutta de 3er orden
res3 <- runge_kutta_3(f3, a3, b3, y03, N)
# Graficar (filtrando NA)
validos <- !is.na(res3$y)
plot(res3$t[validos], res3$y[validos], type = "l", col = "purple", lwd = 2,
main = "Problema 3: Runge-Kutta de 3er Orden",
xlab = "x", ylab = "y(x)")
#| code-fold: true
f3 <- function(x, y) {
if (is.na(x) || is.na(y) || is.nan(x) || is.nan(y)) return(NA)
if ((1 - x^2) <= 0 || (1 - y^2) <= 0 || abs(y) < 1e-8) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0
b3 <- 1
y03 <- 1
N <- 1000
res3 <- euler_modificado(f3, a3, b3, y03, N)
validos <- !is.na(res3$y)
plot(res3$t[validos], res3$y[validos], type = "l", col = "purple", lwd = 2,
main = "Problema 3: Euler Modificado (condición correcta)",
xlab = "x", ylab = "y(x)")
res3
#| code-fold: true
f3 <- function(x, y) {
# if (is.na(x) || is.na(y) || is.nan(x) || is.nan(y)) return(NA)
# if ((1 - x^2) <= 0 || (1 - y^2) <= 0 || abs(y) < 1e-8) return(NA)
- (x * sqrt(1 - y^2)) / (y * sqrt(1 - x^2))
}
a3 <- 0
b3 <- 1
y03 <- 1
N <- 1000
res3 <- euler_modificado(f3, a3, b3, y03, N)
validos <- !is.na(res3$y)
plot(res3$t[validos], res3$y[validos], type = "l", col = "purple", lwd = 2,
main = "Problema 3: Euler Modificado (condición correcta)",
xlab = "x", ylab = "y(x)")
tinytex::uninstall_tinytex()
tinytex::install_tinytex()
tinytex::tlmgr_update()
tinytex::tlmgr_install("l3kernel")
