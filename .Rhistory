df_nodos <- data.frame(x = x, y = y,
etiqueta = paste0("(", x, ", ", y, ")"))
# Gráfico
ggplot() +
geom_line(aes(x = x_vals, y = y_vals), color = "darkred", linewidth = 1.3) +
geom_point(data = df_nodos, aes(x = x, y = y), size = 3, shape = 21, fill = "white") +
geom_text(data = df_nodos, aes(x = x, y = y, label = etiqueta),
vjust = -1.2, size = 3.5) +
labs(
title = "Interpolación polinómica con nodos: (-2,-1.2), (-1,0.5), (0,1), (1,2.8), (2,3.5)",
subtitle = "Polinomio P[n](x) tal que  Pₙ(xᵢ) = yᵢ",
x = "x",
y = "y"
) +
theme_minimal(base_size = 14)
# Paquetes necesarios
library(ggplot2)
# Datos de los nodos
x <- c(-2, -1, 0, 1, 2)
y <- c(-1.2, 0.5, 1, 2.8, 3.5)
# Ajuste del polinomio interpolante de grado 4
modelo <- lm(y ~ poly(x, 4, raw = TRUE))
# Datos para graficar el polinomio
x_vals <- seq(min(x) - 0.5, max(x) + 0.5, length.out = 500)
y_vals <- predict(modelo, newdata = data.frame(x = x_vals))
# Crear un data frame con los nodos para etiquetas
df_nodos <- data.frame(x = x, y = y,
etiqueta = paste0("(", x, ", ", y, ")"))
# Gráfico
ggplot() +
geom_line(aes(x = x_vals, y = y_vals), color = "darkred", linewidth = 1.3) +
geom_point(data = df_nodos, aes(x = x, y = y), size = 3, shape = 21, fill = "white") +
geom_text(data = df_nodos, aes(x = x, y = y, label = etiqueta),
vjust = -1.2, size = 3.5) +
labs(
title = "Interpolación polinómica con nodos: (-2,-1.2), (-1,0.5), (0,1), (1,2.8), (2,3.5)",
subtitle = "Polinomio P[n](x) tal que  Pₙ(xᵢ) = yᵢ",
x = "x",
y = "y"
) +
theme_minimal(base_size = 14)
#| code-fold: true
#| fig-cap: "Comparación de métodos - Función 1"
nodos1 <- c(1, 1.5, 2, 2.5, 3)
valores1 <- f1(nodos1)
derivadas1 <- df1(nodos1)
#| code-fold: true
# Neville: interpolacion en un punto x a partir de un vector de nodos (xi) y otro de valores (f(xi))
# Retorna una lista con el valor interpolado y la matriz completa Q (la que posee todos los polinomios utilizados para la construccion del polinomio completo)
neville <- function(nodos, valores, x) {
stopifnot(is.numeric(nodos),
is.numeric(valores),
length(nodos) == length(valores))
n <- length(nodos)
Q <- matrix(NA_real_, nrow = n, ncol = n)
# Columna inicial con valores de Y
Q[, 1] <-  valores
# Construccion de la tabla de Neville
for (i in 2:n) {
for (j in 2:i) {
numerador <- ((x - nodos[i - j + 1]) * Q[i, j - 1] - (x - nodos[i]) * Q[i -
1, j - 1])
denominador <- nodos[i] - nodos[i - j + 1]
Q[i, j] <-  numerador / denominador
}
}
return(list(valor = Q[n, n], tabla = Q))
}
#| code-fold: true
# Lagrange.Newton: interpolacion en un punto x function# Lagrange.Newton: interpolacion en un punto x a partir de un vector de nodos y otro de valores
# Retorna una lista con el valor interpolado, la matriz para la construccion de los coeficientes, y un vector de los coeficientes del polinomio de lagrange
lagrange.newton <- function(nodos, valores, x) {
stopifnot(is.numeric(nodos),
is.numeric(valores),
length(nodos) == length(valores))
n <- length(nodos)
Q <- matrix(NA_real_, nrow = n, ncol = n)
Q[, 1] <- valores
# Construccion de la tabla de diferencias de Newton
for (i in 2:n) {
for (j in 2:i) {
numerador <- Q[i, j - 1] - Q[i - 1, j - 1]
denominador <- nodos[i] - nodos[i - j + 1]
Q[i, j] <-  numerador / denominador
}
}
coeficientes <- diag(Q)
valor = Q[1, 1]
producto = 1
for (i in 2:n) {
producto <- producto * (x - nodos[i - 1])
valor <- valor + coeficientes[i] * producto
}
return(list(
valor = valor,
tabla = Q,
coeficientes = coeficientes
))
}
#| code-fold: true
# Hermite.newton: interpolacion en un punto x a partir de un vector de nodos, otro de valores y otro de derivadas
# Retorna una lista con el valor interpolado, la matriz para la construccion de los  y un vector de los coeficientes
hermite.newton <- function(nodos, valores, derivadas, x) {
stopifnot(
is.numeric(nodos),
is.numeric(valores),
is.numeric(derivadas),
length(nodos) == length(valores),
length(nodos) == length(derivadas)
)
n <- length(nodos)
Z <- numeric(2 * n)
Q <- matrix(0, nrow = 2 * n, ncol = 2 * n)
# Set-up inicial de la matriz
for (i in 1:n) {
z0 <- 2 * i - 1
z1 <- 2 * i
Z[z0] <- nodos[i]
Z[z1] <- nodos[i]
Q[z0, 1] <- valores[i]
Q[z1, 1] <- valores[i]
Q[z1, 2] <- derivadas[i]
if (i != 1) {
Q[z0, 2] <- (Q[z0, 1] - Q[z0 - 1, 1]) / (Z[z0] - Z[z0 - 1])
}
}
# Rellenar el resto de la matriz a partir de estos valores
for (i in 3:(2 * n)) {
for (j in 3:i) {
Q[i, j] <- (Q[i, j - 1] - Q[i - 1, j - 1]) / (Z[i] - Z[i - j + 1])
}
}
coeficientes <- diag(Q)
valor <- Q[1, 1]
producto <- 1
for (i in 2:(2 * n)) {
producto <- producto * (x - Z[i - 1])
valor <- valor + coeficientes[i] * producto
}
return(list(
valor = valor,
tabla = Q,
coeficientes = coeficientes
))
}
#| code-fold: true
# spline.natural: funcion que calcula la interpolacion por splines a partir de unos nodos y sus valores
# Retorna los valores de los coeficientes a, b, c, d de cada una de las n-1 ecuaciones generadas
spline.natural <- function(nodos, valores, x) {
# Note que los valores de a corresponden a los valores de los nodos en la funcion, por lo que cuando aparezca el vector "valores" se debe entender que equivale al vector "a"
n <- length(nodos)
h <- numeric(n - 1)
alfa <- numeric(n - 1)
alfa[1] <- 0
# Paso 1 y 2: definir los h's y alfas
for (i in 1:(n - 1)) {
h[i] <- nodos[i + 1] - nodos[i]
if (i != 1) {
alfa[i] <- (3 / h[i]) * (valores[i + 1] - valores[i]) - (3 / h[i - 1]) *
(valores[i] - valores[i - 1])
}
}
#Paso 3: definir valores iniciales de l, m, y z
l <- numeric(n) # creo que el tamano de esto puede ser n-1
l[1] <- 1
m <- numeric(n - 1)
m[1] <- 0
z <- numeric(n) # creo que el tamano de esto puede ser n-1
z[1] <- 0
# Paso 4: rellenar vectores l, m, z
for (i in 2:(n - 1)) {
l[i] <- 2 * (nodos[i + 1] - nodos[i - 1]) - h[i - 1] * m[i - 1]
m[i] <- h[i] / l[i]
z[i] <- (alfa[i] - h[i - 1] * z[i - 1]) / l[i]
}
# Paso 5: definir valores finales
l[n] <- 1 #creo que esto no hace falta
z[n] <- 0 #esto tampoco
c <- numeric(n)
c[n] <- 0
b <- numeric(n)
d <- numeric(n)
# Paso 6: sustitucion hacia atras
for (j in (n - 1):1) {
c[j] <- z[j] - m[j] * c[j + 1]
b[j] <- (valores[j + 1] - valores[j]) / h[j] - (h[j] / 3) * (c[j + 1] +
2 * c[j])
d[j] <- (c[j + 1] - c[j]) / (3 * h[j])
}
# Paso extra: evaluar la interpolacion en el punto x especificado
## Encontramos los dos nodos que estan prensando al intervalo
indice <- NULL
for (i in 1:(n - 1)) {
if (x >= nodos[i] && x < nodos[i + 1]) {
indice <- i
}
}
if(x == nodos[n]){
indice <- n
}
if (is.null(indice)) {
return("El valor de interpolacion debe estar entre dos nodos")
}
## evaluamos en la funcion asociada
valor <- valores[indice] + b[indice] * (x - nodos[indice]) + c[indice] * (x - nodos[indice])^2 + d[indice] * (x - nodos[indice])^3
return(list(
a = valores,
b = b,
c = c,
d = d,
valor = valor
))
}
#| code-fold: true
# spline.sujeto: funcion que calcula la interpolacion por splines a partir de unos nodos y sus valores
# Retorna los valores de los coeficientes a, b, c, d de cada una de las n-1 ecuaciones generadas
spline.sujeto <- function(nodos, valores, derivadas, x) {
# Note que los valores de a corresponden a los valores de los nodos en la funcion, por lo que cuando aparezca el vector "valores" se debe entender que equivale al vector "a"
stopifnot(length(derivadas) == 2)
n <- length(nodos)
h <- numeric(n - 1)
alfa <- numeric(n)
# Paso 1 y 2: definir los h's y alfas
for (i in 1:(n - 1)) {
h[i] <- nodos[i + 1] - nodos[i]
if (i != 1) {
alfa[i] <- (3 / h[i]) * (valores[i + 1] - valores[i]) - (3 / h[i - 1]) *
(valores[i] - valores[i - 1])
}
}
alfa[1] <- 3 * ((valores[2] - valores[1]) / h[1] - derivadas[1])
alfa[n] <- 3 * (derivadas[2] - (valores[n] - valores[n - 1]) / h[n - 1])
#Paso 3: definir valores iniciales de l, m, y z
l <- numeric(n) # creo que el tamano de esto puede ser n-1
l[1] <- 2 * h[1]
m <- numeric(n - 1)
m[1] <- 1 / 2
z <- numeric(n) # creo que el tamano de esto puede ser n-1
z[1] <- alfa[1] / l[1]
# Paso 4: rellenar vectores l, m, z
for (i in 2:(n - 1)) {
l[i] <- 2 * (nodos[i + 1] - nodos[i - 1]) - h[i - 1] * m[i - 1]
m[i] <- h[i] / l[i]
z[i] <- (alfa[i] - h[i - 1] * z[i - 1]) / l[i]
}
# Paso 5: definir valores finales
l[n] <- h[n - 1] * (2 - m[n - 1])
z[n] <- (alfa[n] - h[n - 1] * z[n - 1]) / l[n]
c <- numeric(n)
c[n] <- z[n]
b <- numeric(n)
d <- numeric(n)
# Paso 6: sustitucion hacia atras
for (j in (n - 1):1) {
c[j] <- z[j] - m[j] * c[j + 1]
b[j] <- (valores[j + 1] - valores[j]) / h[j] - (h[j] / 3) * (c[j + 1] + 2 * c[j])
d[j] <- (c[j + 1] - c[j]) / (3 * h[j])
}
# Paso extra: evaluar la interpolacion en el punto x especificado
## Encontramos los dos nodos que estan prensando al intervalo
indice <- NULL
for (i in 1:(n - 1)) {
if (x >= nodos[i] && x < nodos[i + 1]) {
indice <- i
}
}
if (x == nodos[n]) {
indice <- n
}
if (is.null(indice)) {
return("El valor de interpolacion debe estar entre dos nodos")
}
## evaluamos en la funcion asociada
valor <- valores[indice] + b[indice] * (x - nodos[indice]) + c[indice] * (x - nodos[indice])^2 + d[indice] * (x - nodos[indice])^3
return(list(
a = valores,
b = b,
c = c,
d = d,
valor = valor
))
}
#| message: false
#| warning: false
#| code-fold: true
library(tidyverse)
graficar.polinomio <- function(nodos,
a,
b,
metodo,
f = NULL,
valores = NULL,
df = NULL,
derivadas = NULL,
derivadas.clamped = NULL) {
stopifnot(is.numeric(nodos), length(nodos) >= 2)
# Validación: exactamente uno de f o valores
if (is.null(f) == is.null(valores)) {
stop("Debe proveer exactamente uno: 'f' (función) o 'valores' (numérico).")
}
# Valores en nodos
if (!is.null(f)) {
stopifnot(is.function(f))
valores_nodos <- f(nodos)
} else {
stopifnot(is.numeric(valores), length(valores) == length(nodos))
valores_nodos <- valores
}
# ---- Derivadas en nodos (si aplica) ----
derivadas_nodos <- NULL
# Si llegan ambos, priorizamos 'derivadas' y avisamos
if (!is.null(df) && !is.null(derivadas)) {
warning("Se pasaron 'df' y 'derivadas'; se usará 'derivadas'.")
}
if (!is.null(derivadas)) {
stopifnot(is.numeric(derivadas), length(derivadas) == length(nodos))
derivadas_nodos <- derivadas
} else if (!is.null(df)) {
if (is.function(df)) {
derivadas_nodos <- df(nodos)
} else if (is.numeric(df)) {
stopifnot(length(df) == length(nodos))
derivadas_nodos <- df
} else {
stop("`df` debe ser función o vector numérico de derivadas en los nodos.")
}
}
# Wrapper vectorizado para el método (con o sin derivadas)
if (!is.null(derivadas_nodos)) {
H <- function(x)
vapply(x, function(xx)
metodo(nodos, valores_nodos, derivadas_nodos, xx)$valor, numeric(1))
} else {
if (is.null(derivadas.clamped)) {
H <- function(x)
vapply(x, function(xx)
metodo(nodos, valores_nodos, xx)$valor, numeric(1))
} else {
H <- function(x)
vapply(x, function(xx)
spline.sujeto(nodos, valores_nodos, derivadas.clamped, xx)$valor, numeric(1))
}
}
# Malla y data frames
xi <- seq(a, b, length.out = 400)
df_plot <- data.frame(
x  = xi,
Hx = H(xi),
fx = if (!is.null(f)) f(xi) else NA_real_
)
df_nodos <- data.frame(x = nodos, y = valores_nodos)
# Gráfico
p <- ggplot(df_plot, aes(x = x))
if (!is.null(f)) {
p <- p +
geom_line(aes(y = fx, color = "Original"), linewidth = 1) +
geom_line(aes(y = Hx, color = "Interpolación"),
linewidth = 1, linetype = "dashed") +
scale_color_manual(values = c("Original" = "blue", "Interpolación" = "red"))
} else {
p <- p +
geom_line(aes(y = Hx, color = "Interpolación"), linewidth = 1) +
scale_color_manual(values = c("Interpolación" = "red"))
}
p +
geom_point(data = df_nodos, aes(x = x, y = y),
shape = 21, size = 3, fill = "white") +
labs(title = paste0("Interpolación por ", deparse(substitute(metodo))),
y = "Valor", color = "Serie") +
theme_minimal(base_size = 14)
}
#| code-fold: true
f <- function(x) log(x)
df <- function(x) 1/x
nodos <- c(0.1, 0.5, 1, 1.5, 2)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], neville, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], lagrange.newton, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], hermite.newton, f = f, df = df)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], spline.natural, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], spline.sujeto, f = f, derivadas.clamped = c(df(nodos[1]), df(nodos[length(nodos)])))
neville(c(0.2, 0.4, 0.6, 0.8, 1.0), c(0.9798652, 0.9177710, 0.8080348, 0.6386093, 0.3843735), 0.5)
f <- function(x) 3*x*exp(x) - exp(2*x)
nodos <- c(1, 1.05, 1.07)
valores <- f(nodos)
valor.a <- neville(nodos, valores, 1.03)$valor
valor.a
nodos <- c(nodos, 1.04)
valores <- f(nodos)
valor.b <- neville(nodos, valores, 1.03)$valor
valor.b
error.real.a <- abs(valor.a-f(1.03))
error.real.a
error.real.b <- abs(valor.b-f(1.03))
error.real.b
# FALTA METER ERROR TEORICO
f <- function(x) 3*x*exp(x) - exp(2*x)
df <- function(x) 3*x*exp(x) + 3*exp(x) -2*exp(2*x)
nodos <- c(1, 1.05, 1.07)
valores <- f(nodos)
derivadas <- df(nodos)
valor.a <- hermite.newton(nodos, valores, derivadas, 1.03)$valor
valor.a
nodos <- c(nodos, 1.04)
valores <- f(nodos)
derivadas <- df(nodos)
valor.b <- hermite.newton(nodos, valores, derivadas, 1.03)$valor
valor.b
error.real.a <- abs(valor.a-f(1.03))
error.real.a
error.real.b <- abs(valor.b-f(1.03))
error.real.b
# FALTA METER ERROR TEORICO
nodos <- c(0, 0.1, 0.3, 0.6, 1)
valores <- c(-7, -5.89483, -5.65014, -5.17788, -4.28172)
lagrange.newton(nodos, valores, 1)
graficar.polinomio(nodos, 0, 1, lagrange.newton, valores = valores)
nodos     <- c(0.2, 0.4, 0.6, 0.8, 1.0)
valores   <- c(0.9798652, 0.9177710, 0.8080348, 0.6386093, 0.3843735)
derivadas <- c(0.20271,   0.42279,   0.68414,   1.02964,   1.55741)
hermite.newton(nodos, valores, derivadas, 0.2)
graficar.polinomio(nodos, 0.2, 1, hermite.newton, valores = valores, derivadas = derivadas)
#| code-fold: true
# Funciones
f1 <- function(x) 3 * x^2 * log(x) + 2 * x
f2 <- function(x) x^2 * sin(x) - 3 * cos(x)
f3 <- function(x) x * cos(x) - 2 * x^2 + 3 * x - 1
# Derivadas
df1 <- function(x) 6 * x * log(x) + 3 * x + 2
df2 <- function(x) 2 * x * sin(x) + x^2 * cos(x) + 3 * sin(x)
df3 <- function(x) cos(x) - x * sin(x) - 4 * x + 3
#| code-fold: true
#| fig-cap: "Interpolación de Lagrange - Función 1"
graficar.polinomio(c(1, 1.5, 2, 2.5, 3), 1, 3, lagrange.newton, f = f1)
#| code-fold: true
#| fig-cap: "Interpolación de Lagrange - Función 2"
graficar.polinomio(c(1, 2, 3, 4, 5), 1, 5, lagrange.newton, f = f2)
#| code-fold: true
#| fig-cap: "Interpolación de Lagrange - Función 3"
graficar.polinomio(c(1, 2, 3, 4, 5), 1, 5, lagrange.newton, f = f3)
#| code-fold: true
#| fig-cap: "Interpolación por Splines naturales - Función 1"
graficar.polinomio(c(1, 1.5, 2, 2.5, 3), 1, 3, spline.natural, f = f1)
#| code-fold: true
#| fig-cap: "Interpolación por Splines naturales - Función 2"
graficar.polinomio(c(1, 2, 3, 4, 5), 1, 5, spline.natural, f = f2)
#| code-fold: true
#| fig-cap: "Interpolación por Splines naturales - Función 3"
graficar.polinomio(c(1, 2, 3, 4, 5), 1, 5, spline.natural, f = f3)
#| code-fold: true
#| fig-cap: "Interpolación de Hermite - Función 1"
graficar.polinomio(c(1, 1.5, 2, 2.5, 3), 1, 3, hermite.newton, f = f1, df = df1)
```
#| code-fold: true
#| fig-cap: "Comparación de métodos - Función 1"
nodos1 <- c(1, 1.5, 2, 2.5, 3)
valores1 <- f1(nodos1)
derivadas1 <- df1(nodos1)
xi <- seq(1, 3, length.out = 400)
df_comp1 <- tibble(
x = xi,
`f(x)` = f1(xi),
Lagrange = vapply(xi, function(x) lagrange.newton(nodos1, valores1, x)$valor, numeric(1)),
Hermite = vapply(xi, function(x) hermite.newton(nodos1, valores1, derivadas1, x)$valor, numeric(1)),
Splines = vapply(xi, function(x) spline.natural(nodos1, valores1, x)$valor, numeric(1))
) |> pivot_longer(-x, names_to = "Método", values_to = "y")
ggplot(df_comp1, aes(x = x, y = y, color = Método)) +
geom_line(linewidth = 1) +
geom_point(data = tibble(x = nodos1, y = valores1),
aes(x = x, y = y, color = "Nodos"),
shape = 21, fill = "white", size = 2) +
labs(title = "Comparación de métodos de interpolación - Función 1") +
theme_minimal(base_size = 14)
#| code-fold: true
#| fig-cap: "Comparación de métodos de interpolación - Función 2"
nodos2 <- c(1, 2, 3, 4, 5)
valores2 <- f2(nodos2)
derivadas2 <- df2(nodos2)
xi2 <- seq(1, 5, length.out = 400)
df_comp2 <- tibble(
x = xi2,
`f(x)` = f2(xi2),
Lagrange = vapply(xi2, function(x) lagrange.newton(nodos2, valores2, x)$valor, numeric(1)),
Hermite = vapply(xi2, function(x) hermite.newton(nodos2, valores2, derivadas2, x)$valor, numeric(1)),
Splines = vapply(xi2, function(x) spline.natural(nodos2, valores2, x)$valor, numeric(1))
) |> pivot_longer(-x, names_to = "Método", values_to = "y")
ggplot(df_comp2, aes(x = x, y = y, color = Método)) +
geom_line(linewidth = 1) +
geom_point(data = tibble(x = nodos2, y = valores2),
aes(x = x, y = y, color = "Nodos"),
shape = 21, fill = "white", size = 2) +
labs(title = "Comparación de métodos de interpolación - Función 2") +
theme_minimal(base_size = 14)
#| code-fold: true
#| fig-cap: "Comparación de métodos de interpolación - Función 3"
nodos3 <- c(1, 2, 3, 4, 5)
valores3 <- f3(nodos3)
derivadas3 <- df3(nodos3)
xi3 <- seq(1, 5, length.out = 400)
df_comp3 <- tibble(
x = xi3,
`f(x)` = f3(xi3),
Lagrange = vapply(xi3, function(x) lagrange.newton(nodos3, valores3, x)$valor, numeric(1)),
Hermite = vapply(xi3, function(x) hermite.newton(nodos3, valores3, derivadas3, x)$valor, numeric(1)),
Splines = vapply(xi3, function(x) spline.natural(nodos3, valores3, x)$valor, numeric(1))
) |> pivot_longer(-x, names_to = "Método", values_to = "y")
ggplot(df_comp3, aes(x = x, y = y, color = Método)) +
geom_line(linewidth = 1) +
geom_point(data = tibble(x = nodos3, y = valores3),
aes(x = x, y = y, color = "Nodos"),
shape = 21, fill = "white", size = 2) +
labs(title = "Comparación de métodos de interpolación - Función 3") +
theme_minimal(base_size = 14)
