if (abs(p - p0_tem) < tol) {
return(p)
}
i <- i + 1
p0_tem <- p
}
cat("El método no converge\n")
return(NULL)
}
g <- function(x) exp(-x)
sol3 <- punto.fijo(p0 = 0.55, tol = 1e-6, n = 30, g = g)
cat("Soluci´on punto.fijo:", sol3, "\n")
Soluci´on punto.fijo: 0.5671437
cat("Soluci´on punto.fijo:", sol3, "\n")
#| echo: false
cat("Solución punto.fijo:", sol3, "\n")
#| code-fold: true
punto.fijo.recursivo <- function(p0, tol, n, g) {
p1 <- g(p0)
if (abs(p0 - p1) < tol || n < 1) {
if (n > 1) {
return(p1)
} else {
return(Inf)
}
} else {
return(punto.fijo.recursivo(p1, tol, n - 1, g))
}
}
sol3 <- punto.fijo.recursivo(p0 = 0.55, tol = 1e-6, n = 30, g = g)
cat("Solución punto.fijo.recursivo:", sol3, "\n")
# Definir los valores de x
x <- seq(0.01, 3, by = 0.01)
# Definir la función G(x)
G <- function(x) sqrt(1 + 1/x)
# Crear el gráfico
plot(x, G(x), type = "l", col = "blue", lwd = 2,
ylim = c(0, 3.2), xlab = "x", ylab = "y", main = "Gráfico de G(x) y x")
# Agregar la recta y = x
lines(x, x, col = "red", lty = 2, lwd = 2)
# Agregar leyenda
legend("topright", legend = c("G(x) = sqrt(1 + 1/x)", "y = x"),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Llamada a la función biseccion
```
?format
#| echo: false
cat("error absoluto:", format(err.abs.b, scientific = F))
cat("error relativo:", err.rel.b)
#| echo: false
cat("error absoluto:", format(err.abs.b, scientific = F))
cat("error relativo:", err.rel.b)
#| code-fold: true
err.abs.b <- abs(pi/1000 - 0.0031)
err.rel.b <- err.abs.b/(pi/1000)
#| echo: false
cat("error absoluto:", format(err.abs.b, scientific = F))
cat("error relativo:", err.rel.b)
e-4
0.8e-4
format(0.8e-4, cientific = F)
format(0.8e-4, scientific = F)
prod.punto.12 <- function(f, g) {
h <- function(x){ f(x) * g(x) }
h <- Vectorize(h)
integrate(h, 0, 1)$value
}
norma.12 <- function(f) {
sqrt(prod.punto.12(f, f))
}
proy.ortogonal.12 <- function(u, v) {
coef <- prod.punto.12(u, v) / prod.punto.12(v, v)
function(x) coef * v(x)
}
gs.ortogonal.12 <- function(base) {
U <- base
Q <- list()
for (k in seq_along(U)) {
u <- U[[k]]
if (length(Q) > 0) {
for (q in Q) {
old_u <- u
u <- function(x, old_u=old_u, q=q) {
force(old_u); force(q)
old_u(x) - proy.ortogonal.12(old_u, q)(x)
}
}
}
Q[[length(Q) + 1]] <- u
}
return(Q)
}
gs.ortonormal.12 <- function(base) {
base.ortogonal <- gs.ortogonal.12(base)
ortonormal <- lapply(base.ortogonal, function(f) {
n <- norma.12(f)
function(x) f(x)/n
})
return(ortonormal)
}
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
ortonormal <- gs.ortonormal.12(base)
# Producto interno entre ortonormal[1] y ortonormal[2] ≈ 0
prod.punto.12(ortonormal[[1]], ortonormal[[2]])
prod.punto.12 <- function(f, g) {
h <- function(x){ f(x) * g(x) }
h <- Vectorize(h)
integrate(h, 0, 1)$value
}
norma.12 <- function(f) {
sqrt(prod.punto.12(f, f))
}
proy.ortogonal.12 <- function(u, v) {
coef <- prod.punto.12(u, v) / prod.punto.12(v, v)
function(x) coef * v(x)
}
gs.ortogonal.12 <- function(base) {
U <- base
Q <- list()
for (k in seq_along(U)) {
u <- U[[k]]
if (length(Q) > 0) {
for (q in Q) {
u_prev <- u
u <- (function(old_u, q) {
function(x) old_u(x) - proy.ortogonal.12(old_u, q)(x)
})(u_prev, q)
}
}
Q[[length(Q) + 1]] <- u
}
return(Q)
}
gs.ortonormal.12 <- function(base) {
base.ortogonal <- gs.ortogonal.12(base)
ortonormal <- lapply(base.ortogonal, function(f) {
n <- norma.12(f)
function(x) f(x)/n
})
return(ortonormal)
}
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
ortonormal <- gs.ortonormal.12(base)
# Producto interno entre ortonormal[1] y ortonormal[2] ≈ 0
prod.punto.12(ortonormal[[1]], ortonormal[[2]])
# Producto interno en [0,1]
prod.punto.12 <- function(f, g) {
h <- function(x){ f(x) * g(x) }
h <- Vectorize(h)
integrate(h, 0, 1)$value
}
# Norma inducida
norma.12 <- function(f) {
sqrt(prod.punto.12(f, f))
}
# Proyección ortogonal de u sobre v
proy.ortogonal.12 <- function(u, v) {
coef <- prod.punto.12(u, v) / prod.punto.12(v, v)
function(x) coef * v(x)
}
# Ortogonalización de Gram-Schmidt
gs.ortogonal.12 <- function(base) {
U <- base
Q <- list()
for (k in seq_along(U)) {
u <- U[[k]]
if (length(Q) > 0) {
for (q in Q) {
# Solución segura: capturar old_u y q en un closure
u_prev <- u
u <- (function(old_u, q) {
function(x) old_u(x) - proy.ortogonal.12(old_u, q)(x)
})(u_prev, q)
}
}
Q[[length(Q) + 1]] <- u
}
return(Q)
}
# Ortogonalización + normalización
gs.ortonormal.12 <- function(base) {
base.ortogonal <- gs.ortogonal.12(base)
ortonormal <- lapply(base.ortogonal, function(f) {
n <- norma.12(f)
function(x) f(x) / n
})
return(ortonormal)
}
# Funciones base
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
# Base ortonormalizada
ortonormal <- gs.ortonormal.12(base)
# Producto interno entre funciones ortonormales (debe ser ~0 o ~1)
prod.punto.12(ortonormal[[1]], ortonormal[[2]])  # ≈ 0
prod.punto.12(ortonormal[[1]], ortonormal[[1]])  # ≈ 1
prod.punto.12(ortonormal[[2]], ortonormal[[3]])  # ≈ 0
# Producto interno en [0,1]
prod.punto.12 <- function(f, g) {
h <- Vectorize(function(x) f(x) * g(x))
integrate(h, 0, 1)$value
}
# Norma inducida
norma.12 <- function(f) {
sqrt(prod.punto.12(f, f))
}
# Proyección ortogonal de u sobre v
proy.ortogonal.12 <- function(u, v) {
coef <- prod.punto.12(u, v) / prod.punto.12(v, v)
function(x) coef * v(x)
}
# Ortogonalización de Gram-Schmidt (segura)
gs.ortogonal.12 <- function(base) {
Q <- list()
for (k in seq_along(base)) {
u_k <- base[[k]]
for (q in Q) {
proj <- proy.ortogonal.12(u_k, q)
prev_u_k <- u_k
u_k <- function(x, prev_u_k = prev_u_k, proj = proj) {
prev_u_k(x) - proj(x)
}
}
Q[[length(Q) + 1]] <- u_k
}
Q
}
# Ortogonalización + normalización
gs.ortonormal.12 <- function(base) {
base_ortogonal <- gs.ortogonal.12(base)
lapply(base_ortogonal, function(f) {
n <- norma.12(f)
function(x) f(x) / n
})
}
# Funciones base
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
# Base ortonormalizada
ortonormal <- gs.ortonormal.12(base)
# Verificación de ortogonalidad
prod.punto.12(ortonormal[[1]], ortonormal[[2]])  # ≈ 0
prod.punto.12(ortonormal[[2]], ortonormal[[3]])  # ≈ 0
# Verificación de normalidad
sapply(ortonormal, norma.12)  # Todos ≈ 1
# Producto interno en [0,1]
prod.punto.12 <- function(f, g) {
h <- Vectorize(function(x) f(x) * g(x))
integrate(h, 0, 1)$value
}
# Norma inducida
norma.12 <- function(f) {
sqrt(prod.punto.12(f, f))
}
# Proyección ortogonal de u sobre v
proy.ortogonal.12 <- function(u, v) {
coef <- prod.punto.12(u, v) / prod.punto.12(v, v)
function(x) coef * v(x)
}
# Ortogonalización de Gram-Schmidt (segura)
gs.ortogonal.12 <- function(base) {
Q <- list()
for (k in seq_along(base)) {
u_k <- base[[k]]
for (q in Q) {
proj <- proy.ortogonal.12(u_k, q)
prev_u_k <- u_k  # Capturamos el estado anterior
u_k <- (function(prev, pj) {
function(x) prev(x) - pj(x)
})(prev_u_k, proj)  # Closure: evita usar argumentos predeterminados
}
Q[[length(Q) + 1]] <- u_k
}
Q
}
# Ortogonalización + normalización
gs.ortonormal.12 <- function(base) {
base_ortogonal <- gs.ortogonal.12(base)
lapply(base_ortogonal, function(f) {
n <- norma.12(f)
function(x) f(x) / n
})
}
# Funciones base
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
# Base ortonormalizada
ortonormal <- gs.ortonormal.12(base)
# Verificación de ortogonalidad
prod.punto.12(ortonormal[[1]], ortonormal[[2]])  # ≈ 0
prod.punto.12(ortonormal[[2]], ortonormal[[3]])  # ≈ 0
# Verificación de normalidad
sapply(ortonormal, norma.12)  # Todos ≈ 1
# Producto interno en [0,1]
prod.punto.12 <- function(f, g) {
h <- Vectorize(function(x) f(x) * g(x))
integrate(h, 0, 1)$value
}
# Norma inducida
norma.12 <- function(f) {
sqrt(prod.punto.12(f, f))
}
# Proyección ortogonal de u sobre v
proy.ortogonal.12 <- function(u, v) {
coef <- prod.punto.12(u, v) / prod.punto.12(v, v)
function(x) coef * v(x)
}
# Ortogonalización de Gram-Schmidt (segura)
gs.ortogonal.12 <- function(base) {
Q <- list()
for (k in seq_along(base)) {
u_k <- base[[k]]
for (q in Q) {
proj <- proy.ortogonal.12(u_k, q)
prev_u_k <- u_k  # Capturamos el estado anterior
u_k <- (function(prev, pj) {
function(x) prev(x) - pj(x)
})(prev_u_k, proj)  # Closure: evita usar argumentos predeterminados
}
Q[[length(Q) + 1]] <- u_k
}
Q
}
# Ortogonalización + normalización
gs.ortonormal.12 <- function(base) {
base_ortogonal <- gs.ortogonal.12(base)
lapply(base_ortogonal, function(f) {
n <- norma.12(f)
function(x) f(x) / n
})
}
# Funciones base
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
# Base ortonormalizada
ortonormal <- gs.ortonormal.12(base)
# Verificación de ortogonalidad
prod.punto.12(ortonormal[[1]], ortonormal[[2]])  # ≈ 0
prod.punto.12(ortonormal[[2]], ortonormal[[3]])  # ≈ 0
# Verificación de normalidad
sapply(ortonormal, norma.12)  # Todos ≈ 1
# Producto interno en [0,1]
prod.punto.12 <- function(f, g) {
h <- Vectorize(function(x) f(x) * g(x))
integrate(h, 0, 1)$value
}
# Norma inducida
norma.12 <- function(f) {
sqrt(prod.punto.12(f, f))
}
# Proyección ortogonal de u sobre v
proy.ortogonal.12 <- function(u, v) {
coef <- prod.punto.12(u, v) / prod.punto.12(v, v)
function(x) coef * v(x)
}
# Ortogonalización de Gram-Schmidt (segura)
gs.ortogonal.12 <- function(base) {
Q <- list()
for (k in seq_along(base)) {
u_k <- base[[k]]
for (q in Q) {
proj <- proy.ortogonal.12(u_k, q)
prev_u_k <- u_k  # Capturamos el estado anterior
u_k <- (function(prev, pj) {
function(x) prev(x) - pj(x)
})(prev_u_k, proj)  # Closure: evita usar argumentos predeterminados
}
Q[[length(Q) + 1]] <- u_k
}
Q
}
# Ortogonalización + normalización
gs.ortonormal.12 <- function(base) {
base_ortogonal <- gs.ortogonal.12(base)
lapply(base_ortogonal, function(f) {
n <- norma.12(f)
function(x) f(x) / n
})
}
# Funciones base
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
# Base ortonormalizada
ortonormal <- gs.ortonormal.12(base)
# Verificación de ortogonalidad
prod.punto.12(ortonormal[[1]], ortonormal[[2]])  # ≈ 0
prod.punto.12(ortonormal[[2]], ortonormal[[3]])  # ≈ 0
# Verificación de normalidad
sapply(ortonormal, norma.12)  # Todos ≈ 1
# Producto interno en [0,1]
prod.punto.12 <- function(f, g) {
h <- Vectorize(function(x) f(x) * g(x))
result <- integrate(h, 0, 1)
if (!is.finite(result$value)) {
stop("❌ Error: producto interno no finito.")
}
result$value
}
# Norma inducida por el producto interno
norma.12 <- function(f) {
sqrt(prod.punto.12(f, f))
}
# Proyección ortogonal de u sobre v
proy.ortogonal.12 <- function(u, v) {
denom <- prod.punto.12(v, v)
if (denom == 0 || !is.finite(denom)) {
stop("❌ Error: proyección con denominador cero o no finito.")
}
coef <- prod.punto.12(u, v) / denom
function(x) coef * v(x)
}
# Ortogonalización de Gram-Schmidt (segura con closures)
gs.ortogonal.12 <- function(base) {
Q <- list()
for (k in seq_along(base)) {
u_k <- base[[k]]
for (q in Q) {
proj <- proy.ortogonal.12(u_k, q)
prev_u_k <- u_k
u_k <- (function(prev, pj) {
function(x) prev(x) - pj(x)
})(prev_u_k, proj)
}
Q[[length(Q) + 1]] <- u_k
}
Q
}
# Ortogonalización + normalización (segura)
gs.ortonormal.12 <- function(base) {
base_ortogonal <- gs.ortogonal.12(base)
lapply(base_ortogonal, function(f) {
n <- norma.12(f)
if (n == 0 || !is.finite(n)) {
stop("❌ Error: norma no finita o cero.")
}
function(x) f(x) / n
})
}
# Funciones base
f1 <- function(x) 1
f2 <- function(x) x
f3 <- function(x) x^2
base <- list(f1, f2, f3)
# Construcción de la base ortonormal
ortonormal <- gs.ortonormal.12(base)
# Producto punto clásico en R^n
prod.punto.euclideo <- function(x, y) sum(x * y)
# Producto interno en L^2[0,1]: integra f(x)*g(x) de 0 a 1
prod.punto.L2 <- function(f, g) {
h <- Vectorize(function(x) f(x) * g(x))
integrate(h, lower = 0, upper = 1)$value
}
# Norma inducida
norma <- function(v, prod.punto) {
sqrt(prod.punto(v, v))
}
# Proyección ortogonal de u sobre v con producto interno genérico
proy.ortogonal <- function(u, v, prod.punto) {
coef <- prod.punto(u, v) / prod.punto(v, v)
function(x) coef * v(x)
}
# Ortogonalización de Gram-Schmidt genérica
gs.ortogonal <- function(base, prod.punto) {
Q <- list()
for (k in seq_along(base)) {
u_k <- base[[k]]
for (q in Q) {
proy <- proy.ortogonal(u_k, q, prod.punto)
u_k <- (function(prev, pj) {
function(x) prev(x) - pj(x)
})(u_k, proy)
}
Q[[length(Q) + 1]] <- u_k
}
return(Q)
}
# Ortonormalización genérica
gs.ortonormal <- function(base, prod.punto) {
ortogonal <- gs.ortogonal(base, prod.punto)
return(lapply(ortogonal, function(f) {
nrm <- norma(f, prod.punto)
function(x) f(x) / nrm
}))
}
base.funciones <- list(
function(x) 1,
function(x) x,
function(x) x^2
)
# Ortonormalización en L2[0,1]
ortonormal.L2 <- gs.ortonormal(base.funciones, prod.punto.L2)
# Visualizamos los coeficientes en una cuadrícula
curve(ortonormal.L2[[1]](x), 0, 1, col = "blue", lwd = 2)
curve(ortonormal.L2[[2]](x), 0, 1, col = "red", add = TRUE, lwd = 2)
curve(ortonormal.L2[[3]](x), 0, 1, col = "green", add = TRUE, lwd = 2)
legend("topright", legend = c("φ₁", "φ₂", "φ₃"), col = c("blue", "red", "green"), lwd = 2)
