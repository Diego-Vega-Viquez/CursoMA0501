pi
3,14-pi
3.14-pi
abs(pi-3.14)/pi
matrix(1:12, nrow = 3, ncol = 4)
df <- matrix(1:12, nrow = 3, ncol = 4)
df[1:]
df[:1]
df[1]
df[1,2]
df[1,]
df <- matrix(c(1,1,1,1,5:12), nrow = 3, ncol = 4)
df[1,]
df <- matrix(c(1,1,1,1,5:12), nrow = 3, ncol = 4, byrow = TRUE)
df[1,]
df[1,]==1
all(df[1,]==1)
length(df)
df[2]
df
df[2,2]
df[2,2:]
df[2,2:4]
df[1,1:4]
df[2,2:4]
df[3,3:4]
df[4,4:4]
df[2:4,2-1]
df[2:4,1]
df[2:3,2-1]
View(df)
df[-3,-4]
identidad <- function(df) {
size <- ncol(df)
n <- size-1
# Verificación
cond1 <- n == (nrow(df)-1)
cond2 <- all(df[1,]==1)
for (x in 1:n) {
cond3 <- all(df[x,x:size])
if (x > 1) {
cond4 <- all(df[x:size,x-1])
}
}
if (cond1 & cond2 & cond3 & cond4 ) {
return det(df) == prod(diag(df[-1,-1]) - diag(df[-size,-size]))
}
}
biseccion.recursivo <- function(a, b, tol, G) {
A <- a
B <- b
X <- (A + B) / 2
if (G(X) == 0 || abs(B - A) < tol) {
return(X)
} else {
if (G(A) * G(X) > 0) {
return(biseccion.recursivo(X, B, tol, G))
} else {
return(biseccion.recursivo(A, X, tol, G))
}
}
}
# Definir la función
f <- function(x) x^2 - 2
# Llamar al método de bisección
raiz <- biseccion.recursivo(1, 2, tol = 1e-6, G = f)
# Mostrar el resultado
cat("Raíz aproximada:", raiz, "\n")
cat("Error absoluto:", abs(f(raiz)), "\n")
abs(f(raiz))
?format()
format( abs(f(raiz)), digits = 200)
format( abs(f(raiz)), digits = 20)
format( abs(f(raiz)), trim = T, digits = 20)
format( abs(f(raiz)), digits = 20, scientific = F)
pi
(110250-100000)/200000
format((110250-100000)/200000, digits = 20)
format((110250-100000)/200000, digits = 30)
format((110250-100000)/200000, digits = 25)
format((110250-100000)/200000, digits = 21)
format((110250-100000)/200000, digits = 22)
format((110250-100000)/200000, digits = 23)
cat("Soluci´on punto.fijo:", sol3, "\n")
Soluci´on punto.fijo: 0.5671437
g <- function(x) exp(-x)
sol3 <- punto.fijo(p0 = 0.55, tol = 1e-6, n = 30, g = g)
#| echo: false
punto.fijo <- function(p0, tol, n, g) {
i <- 1
p0_tem <- p0
while (i <= n) {
p <- g(p0_tem)
cat(sprintf("En la iteración %d el valor de P es %.15f\n", i, p))
if (abs(p - p0_tem) < tol) {
return(p)
}
i <- i + 1
p0_tem <- p
}
cat("El método no converge\n")
return(NULL)
}
g <- function(x) exp(-x)
sol3 <- punto.fijo(p0 = 0.55, tol = 1e-6, n = 30, g = g)
cat("Soluci´on punto.fijo:", sol3, "\n")
Soluci´on punto.fijo: 0.5671437
cat("Soluci´on punto.fijo:", sol3, "\n")
#| echo: false
cat("Solución punto.fijo:", sol3, "\n")
#| code-fold: true
punto.fijo.recursivo <- function(p0, tol, n, g) {
p1 <- g(p0)
if (abs(p0 - p1) < tol || n < 1) {
if (n > 1) {
return(p1)
} else {
return(Inf)
}
} else {
return(punto.fijo.recursivo(p1, tol, n - 1, g))
}
}
sol3 <- punto.fijo.recursivo(p0 = 0.55, tol = 1e-6, n = 30, g = g)
cat("Solución punto.fijo.recursivo:", sol3, "\n")
# Definir los valores de x
x <- seq(0.01, 3, by = 0.01)
# Definir la función G(x)
G <- function(x) sqrt(1 + 1/x)
# Crear el gráfico
plot(x, G(x), type = "l", col = "blue", lwd = 2,
ylim = c(0, 3.2), xlab = "x", ylab = "y", main = "Gráfico de G(x) y x")
# Agregar la recta y = x
lines(x, x, col = "red", lty = 2, lwd = 2)
# Agregar leyenda
legend("topright", legend = c("G(x) = sqrt(1 + 1/x)", "y = x"),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Llamada a la función biseccion
```
?format
#| echo: false
cat("error absoluto:", format(err.abs.b, scientific = F))
cat("error relativo:", err.rel.b)
#| echo: false
cat("error absoluto:", format(err.abs.b, scientific = F))
cat("error relativo:", err.rel.b)
#| code-fold: true
err.abs.b <- abs(pi/1000 - 0.0031)
err.rel.b <- err.abs.b/(pi/1000)
#| echo: false
cat("error absoluto:", format(err.abs.b, scientific = F))
cat("error relativo:", err.rel.b)
e-4
0.8e-4
format(0.8e-4, cientific = F)
format(0.8e-4, scientific = F)
