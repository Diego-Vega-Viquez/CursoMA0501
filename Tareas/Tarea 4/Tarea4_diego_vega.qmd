---
title: "MA0501 – Tarea 3"
author: 
  - name: "Diego Alberto Vega Víquez - C38367" 
    email: "diegovv13@gmail.com"
  - name: "José Carlos Quintero Cedeño - C26152" 
    email: "jose.quinterocedeno@ucr.ac.cr"
  - name: "Gabriel Valverde Guzmán - C38060"
    email: "GABRIEL.VALVERDEGUZMAN@ucr.ac.cr"
date: today
lang: es
format:
  pdf:
    documentclass: article
    fontsize: 11pt
    linestretch: 1.3
    geometry:
      - top=2.5cm
      - bottom=2.5cm
      - left=2.5cm
      - right=2.5cm
      - headheight=15pt
      - footskip=1.25cm
    toc: true
    toc-depth: 1
    number-sections: false
    classoption:
      - oneside
      - titlepage 
    openany: true
    colorlinks: false   
    top-level-division: section
    include-in-header: 
      text: |
        \usepackage[most]{tcolorbox}
        \usepackage[hidelinks]{hyperref}
        \usepackage{setspace}
        \AtBeginDocument{\setstretch{1.0}} % ← interlineado
  html:
    code-annotations: hover
    toc: true
    toc-depth: 1
    toc-location: left
    toc_float: yes
    html-math-method: katex
    css: styles.css
    df_print: paged
    theme: flatly
    highlight: tango
    embed-resources: true
---

\newpage

# Ejercicio 1

::: {.callout-note title="Instrucción del ejercicio 1"}

Complete las demostraciones que quedaron pendientes en la clase.

:::

**Solución**



# Ejercicio 2

::: {.callout-note title="Instrucción del ejercicio 2"}

Implemente en R los algoritmos de interpolación polinómica vistos en clase.  
Los métodos que se deben implementar son:

a) Interpolar $f(x)$ usando el polinomio de Lagrange con el algoritmo de Neville.  

b) Interpolar $f(x)$ usando el polinomio de Lagrange con el algoritmo de diferencias divididas de Newton.  

c) Interpolar $f(x)$ usando el polinomio de Hermite con el algoritmo de diferencias divididas de Newton.  

d) Interpolar $f(x)$ usando el “Splines” cúbicos naturales y sujetos.  

Luego en general programe una función que permita graficar el polinomio de interpolación y la función correspondiente (si la hay).

:::

**Solución**
**Neville**
```{r}
# Neville: interpolacion en un punto x a partir de un vector de nodos (xi) y otro de valores (f(xi))

# Retorna una lista con el valor interpolado y la matriz completa Q (la que posee todos los polinomios utilizados para la construccion del polinomio completo)

neville <- function(nodos, valores, x) {
  stopifnot(is.numeric(nodos),
            is.numeric(valores),
            length(nodos) == length(valores))
  n <- length(nodos)
  Q <- matrix(NA_real_, nrow = n, ncol = n)
  
  # Columna inicial con valores de Y
  Q[, 1] <-  valores
  
  # Construccion de la tabla de Neville
  for (i in 2:n) {
    for (j in 2:i) {
      numerador <- ((x - nodos[i - j + 1]) * Q[i, j - 1] - (x - nodos[i]) * Q[i -
                                                                                1, j - 1])
      denominador <- nodos[i] - nodos[i - j + 1]
      Q[i, j] <-  numerador / denominador
    }
  }
  return(list(valor = Q[n, n], tabla = Q))
}
```
**Lagrange por diferencias divididas de Newton**
```{r}
# Lagrange.Newton: interpolacion en un punto x function# Lagrange.Newton: interpolacion en un punto x a partir de un vector de nodos y otro de valores

# Retorna una lista con el valor interpolado, la matriz para la construccion de los coeficientes, y un vector de los coeficientes del polinomio de lagrange

lagrange.newton <- function(nodos, valores, x) {
  stopifnot(is.numeric(nodos),
            is.numeric(valores),
            length(nodos) == length(valores))
  n <- length(nodos)
  Q <- matrix(NA_real_, nrow = n, ncol = n)
  
  Q[, 1] <- valores
  
  # Construccion de la tabla de diferencias de Newton
  for (i in 2:n) {
    for (j in 2:i) {
      numerador <- Q[i, j - 1] - Q[i - 1, j - 1]
      denominador <- nodos[i] - nodos[i - j + 1]
      Q[i, j] <-  numerador / denominador
    }
  }
  coeficientes <- diag(Q)
  
  valor = Q[1, 1]
  producto = 1
  
  for (i in 2:n) {
    producto <- producto * (x - nodos[i - 1])
    valor <- valor + coeficientes[i] * producto
  }
  return(list(
    valor = valor,
    tabla = Q,
    coeficientes = coeficientes
  ))
}
```
**Hermite por diferencias divididas de Newton**
```{r}
# Hermite.newton: interpolacion en un punto x a partir de un vector de nodos, otro de valores y otro de derivadas

# Retorna una lista con el valor interpolado, la matriz para la construccion de los  y un vector de los coeficientes

hermite.newton <- function(nodos, valores, derivadas, x) {
  stopifnot(
    is.numeric(nodos),
    is.numeric(valores),
    is.numeric(derivadas),
    length(nodos) == length(valores),
    length(nodos) == length(derivadas)
  )
  n <- length(nodos)
  
  Z <- numeric(2 * n)
  Q <- matrix(0, nrow = 2 * n, ncol = 2 * n)
  
  
  # Set-up inicial de la matriz
  for (i in 1:n) {
    z0 <- 2 * i - 1
    z1 <- 2 * i
    Z[z0] <- nodos[i]
    Z[z1] <- nodos[i]
    Q[z0, 1] <- valores[i]
    Q[z1, 1] <- valores[i]
    Q[z1, 2] <- derivadas[i]
    if (i != 1) {
      Q[z0, 2] <- (Q[z0, 1] - Q[z0 - 1, 1]) / (Z[z0] - Z[z0 - 1])
    }
  }
  # Rellenar el resto de la matriz a partir de estos valores
  for (i in 3:(2 * n)) {
    for (j in 3:i) {
      Q[i, j] <- (Q[i, j - 1] - Q[i - 1, j - 1]) / (Z[i] - Z[i - j + 1])
    }
  }
  
  coeficientes <- diag(Q)
  
  valor <- Q[1, 1]
  producto <- 1
  
  for (i in 2:(2 * n)) {
    producto <- producto * (x - Z[i - 1])
    valor <- valor + coeficientes[i] * producto
  }
  return(list(
    valor = valor,
    tabla = Q,
    coeficientes = coeficientes
  ))
}
```
**Splines cubicos naturales**
```{r}
# spline.natural: funcion que calcula la interpolacion por splines a partir de unos nodos y sus valores

# Retorna los valores de los coeficientes a, b, c, d de cada una de las n-1 ecuaciones generadas
spline.natural <- function(nodos, valores, x) {
  # Note que los valores de a corresponden a los valores de los nodos en la funcion, por lo que cuando aparezca el vector "valores" se debe entender que equivale al vector "a"
  n <- length(nodos)
  
  h <- numeric(n - 1)
  alfa <- numeric(n - 1)
  alfa[1] <- 0
  
  # Paso 1 y 2: definir los h's y alfas
  for (i in 1:(n - 1)) {
    h[i] <- nodos[i + 1] - nodos[i]
    if (i != 1) {
      alfa[i] <- (3 / h[i]) * (valores[i + 1] - valores[i]) - (3 / h[i - 1]) *
        (valores[i] - valores[i - 1])
    }
  }
  
  #Paso 3: definir valores iniciales de l, m, y z
  l <- numeric(n) # creo que el tamano de esto puede ser n-1
  l[1] <- 1
  m <- numeric(n - 1)
  m[1] <- 0
  z <- numeric(n) # creo que el tamano de esto puede ser n-1
  z[1] <- 0
  
  # Paso 4: rellenar vectores l, m, z
  for (i in 2:(n - 1)) {
    l[i] <- 2 * (nodos[i + 1] - nodos[i - 1]) - h[i - 1] * m[i - 1]
    m[i] <- h[i] / l[i]
    z[i] <- (alfa[i] - h[i - 1] * z[i - 1]) / l[i]
  }
  
  # Paso 5: definir valores finales
  l[n] <- 1 #creo que esto no hace falta
  z[n] <- 0 #esto tampoco
  c <- numeric(n)
  c[n] <- 0
  b <- numeric(n)
  d <- numeric(n)
  
  # Paso 6: sustitucion hacia atras
  for (j in (n - 1):1) {
    c[j] <- z[j] - m[j] * c[j + 1]
    b[j] <- (valores[j + 1] - valores[j]) / h[j] - (h[j] / 3) * (c[j + 1] +
                                                                   2 * c[j])
    d[j] <- (c[j + 1] - c[j]) / (3 * h[j])
  }
  
  # Paso extra: evaluar la interpolacion en el punto x especificado
  
  ## Encontramos los dos nodos que estan prensando al intervalo
  indice <- NULL
  for (i in 1:(n - 1)) {
    if (x >= nodos[i] && x < nodos[i + 1]) {
      indice <- i
    }
  }
  if(x == nodos[n]){
    indice <- n
  }
  if (is.null(indice)) {
    return("El valor de interpolacion debe estar entre dos nodos")
  }
  ## evaluamos en la funcion asociada
  
  valor <- valores[indice] + b[indice] * (x - nodos[indice]) + c[indice] * (x - nodos[indice])^2 + d[indice] * (x - nodos[indice])^3
  
  return(list(
    a = valores,
    b = b,
    c = c,
    d = d,
    valor = valor
  ))
}
```
**Splines cubicos sujetos**
```{r}
# spline.sujeto: funcion que calcula la interpolacion por splines a partir de unos nodos y sus valores

# Retorna los valores de los coeficientes a, b, c, d de cada una de las n-1 ecuaciones generadas
spline.sujeto <- function(nodos, valores, derivadas, x) {
  # Note que los valores de a corresponden a los valores de los nodos en la funcion, por lo que cuando aparezca el vector "valores" se debe entender que equivale al vector "a"
  stopifnot(length(derivadas) == 2)
  n <- length(nodos)
  
  h <- numeric(n - 1)
  alfa <- numeric(n - 1)
  
  # Paso 1 y 2: definir los h's y alfas
  for (i in 1:(n - 1)) {
    h[i] <- nodos[i + 1] - nodos[i]
    if (i != 1) {
      alfa[i] <- (3 / h[i]) * (valores[i + 1] - valores[i]) - (3 / h[i - 1]) *
        (valores[i] - valores[i - 1])
    }
  }
  
  alfa[1] <- 3 * ((valores[2] - valores[1]) / h[1] - derivadas[1])
  alfa[n] <- 3 * (derivadas[2] - (valores[n] - valores[n - 1]) / h[n - 1])
  
  #Paso 3: definir valores iniciales de l, m, y z
  l <- numeric(n) # creo que el tamano de esto puede ser n-1
  l[1] <- 2 * h[1]
  m <- numeric(n - 1)
  m[1] <- 1 / 2
  z <- numeric(n) # creo que el tamano de esto puede ser n-1
  z[1] <- alfa[1] / l[1]
  
  # Paso 4: rellenar vectores l, m, z
  for (i in 2:(n - 1)) {
    l[i] <- 2 * (nodos[i + 1] - nodos[i - 1]) - h[i - 1] * m[i - 1]
    m[i] <- h[i] / l[i]
    z[i] <- (alfa[i] - h[i - 1] * z[i - 1]) / l[i]
  }
  
  # Paso 5: definir valores finales
  l[n] <- h[n - 1] * (2 - m[n - 1])
  z[n] <- (alfa[n] - h[n - 1] * z[n - 1]) / l[n]
  c <- numeric(n)
  c[n] <- z[n]
  b <- numeric(n)
  d <- numeric(n)
  
  # Paso 6: sustitucion hacia atras
  for (j in (n - 1):1) {
    c[j] <- z[j] - m[j] * c[j + 1]
    b[j] <- (valores[j + 1] - valores[j]) / h[j] - (h[j] / 3) * (c[j + 1] + 2 * c[j])
    d[j] <- (c[j + 1] - c[j]) / (3 * h[j])
  }
  
  # Paso extra: evaluar la interpolacion en el punto x especificado
  
  ## Encontramos los dos nodos que estan prensando al intervalo
  indice <- NULL
  for (i in 1:(n - 1)) {
    if (x >= nodos[i] && x < nodos[i + 1]) {
      indice <- i
    }
  }
  if (x == nodos[n]) {
    indice <- n
  }
  if (is.null(indice)) {
    return("El valor de interpolacion debe estar entre dos nodos")
  }
  ## evaluamos en la funcion asociada
  
  valor <- valores[indice] + b[indice] * (x - nodos[indice]) + c[indice] * (x - nodos[indice])^2 + d[indice] * (x - nodos[indice])^3
  
  return(list(
    a = valores,
    b = b,
    c = c,
    d = d,
    valor = valor
  ))
}
```
**Funcion de graficacion**
```{r}
graficar.polinomio <- function(nodos,
                               a,
                               b,
                               metodo,
                               f = NULL,
                               valores = NULL,
                               df = NULL,
                               derivadas.clamped = NULL) {
  stopifnot(is.numeric(nodos), length(nodos) >= 2)
  # Validación: exactamente uno de f o valores
  if (is.null(f) == is.null(valores)) {
    stop("Debe proveer exactamente uno: 'f' (función) o 'valores' (numérico).")
  }
  # Obtener valores en nodos según el caso
  if (!is.null(f)) {
    stopifnot(is.function(f))
    valores_nodos <- f(nodos)
  } else {
    stopifnot(is.numeric(valores), length(valores) == length(nodos))
    valores_nodos <- valores
  }
  
  # Derivadas (opcional). Acepta función o vector numérico.
  derivadas_nodos <- NULL
  if (!is.null(df)) {
    if (is.function(df)) {
      derivadas_nodos <- df(nodos)
    } else if (is.numeric(df)) {
      stopifnot(length(df) == length(nodos))
      derivadas_nodos <- df
    } else {
      stop("`df` debe ser función o vector numérico de derivadas en los nodos.")
    }
  }
  
  # Wrapper vectorizado para el método (con o sin derivadas)
  if (!is.null(derivadas_nodos)) {
    H <- function(x)
      vapply(x, function(xx)
        metodo(nodos, valores_nodos, derivadas_nodos, xx)$valor, numeric(1))
  } else {
    if(is.null(derivadas.clamped)){
      H <- function(x)
        vapply(x, function(xx)
          metodo(nodos, valores_nodos, xx)$valor, numeric(1))
    } else{
      H <- function(x)
        vapply(x, function(xx)
          spline.sujeto(nodos, valores_nodos, derivadas.clamped, xx)$valor, numeric(1))
    }
  }
  
  # Malla y data frames
  xi <- seq(a, b, length.out = 400)
  df_plot <- data.frame(x  = xi,
                        Hx = H(xi),
                        fx = if (!is.null(f))
                          f(xi)
                        else
                          NA_real_)
  df_nodos <- data.frame(x = nodos, y = valores_nodos)
  
  # Gráfico: con f (dos curvas) o solo interpolación
  p <- ggplot(df_plot, aes(x = x))
  if (!is.null(f)) {
    p <- p +
      geom_line(aes(y = fx, color = "Original"), linewidth = 1) +
      geom_line(aes(y = Hx, color = "Interpolación"),
                linewidth = 1,
                linetype = "dashed") +
      scale_color_manual(values = c(
        "Original" = "blue",
        "Interpolación" = "red"
      ))
  } else {
    p <- p +
      geom_line(aes(y = Hx, color = "Interpolación"), linewidth = 1) +
      scale_color_manual(values = c("Interpolación" = "red"))
  }
  p +
    geom_point(
      data = df_nodos,
      aes(x = x, y = y),
      shape = 21,
      size = 3,
      fill = "white"
    ) +
    labs(title = paste0("Interpolación por ", deparse(substitute(metodo))), y = "Valor", color = "Serie") +
    theme_minimal(base_size = 14)
}
```
**Pruebas**
```{r}
f <- function(x) log(x)
df <- function(x) 1/x
nodos <- c(0.1, 0.5, 1, 1.5, 2)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], neville, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], lagrange.newton, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], hermite.newton, f = f, df = df)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], spline.natural, f)
graficar.polinomio(nodos, nodos[1], nodos[length(nodos)], spline.sujeto, f = f, derivadas.clamped = c(df(nodos[1]), df(nodos[length(nodos)])))

```





# Ejercicio 3

::: {.callout-note title="Instrucción del ejercicio 3"}

Para el polinomio de Bernstein $B_n(x)$ hacer lo siguiente:

a) Demostrar que para $k \leq n$ se tiene  

$$
\binom{n-1}{k-1} = \frac{k}{n}\binom{n}{k}.
$$

b) Pruebe que, para todo $n \in \mathbb{N}$  

$$
1 = \sum_{k=0}^n \binom{n}{k} x^k (1-x)^{n-k}.
$$

c) Use (b) y (c) para probar que para $f(x) = x^2$  

$$
B_n(x) = \binom{n-1}{n} x^2 + \frac{1}{n}x.
$$

:::

**Solución**



# Ejercicio 4

::: {.callout-note title="Instrucción del ejercicio 4"}

Dada la siguiente tabla de datos para $f(x)$:

| $x$  | $f(x)$     |
|||
| 0.2  | 0.9798652  |
| 0.4  | 0.9177710  |
| 0.6  | 0.8080348  |
| 0.8  | 0.6386093  |
| 1.0  | 0.3843735  |

Aproxime $f(0.5)$ usando el procedimiento **Neville**.

:::

**Solución**



# Ejercicio 5

::: {.callout-note title="Instrucción del ejercicio 5"}

a) Use el algoritmo de Neville para aproximar $f(1.03)$ con $P_{0,1,2}$ para la función  
$$f(x) = 3x e^x - e^{2x}$$  
usando $x_0 = 1$, $x_1 = 1.05$ y $x_2 = 1.07$.

b) Suponga que la aproximación en (a) no es suficientemente exacta. Calcule $P_{0,1,2,3}$ donde $x_3 = 1.04$.

c) Compare el error real en (a) y (b) con la cota del error teórica según los teoremas vistos en clase.

:::

**Solución**



# Ejercicio 6

::: {.callout-note title="Instrucción del ejercicio 6"}

Repita el ejercicio anterior usando el polinomio de interpolación de Hermite, compare resultados.

:::

**Solución**

# Ejercicio 7

::: {.callout-note title="Instrucción del ejercicio 7"}

Use el algoritmo de Diferencias Divididas para construir el polinomio interpolante de grado 4 según la siguiente tabla:

| $x$  | $f(x)$     |
|||
| 0.0  | $-7.00000$ |
| 0.1  | $-5.89483$ |
| 0.3  | $-5.65014$ |
| 0.6  | $-5.17788$ |
| 1.0  | $-4.28172$ |

Grafique este polinomio.

:::

**Solución**



# Ejercicio 8

::: {.callout-note title="Instrucción del ejercicio 8"}

Use el algoritmo de Hermite para construir el polinomio interpolante de Hermite dada la siguiente tabla:

| $x$  | $f(x)$     | $f'(x)$    |
||||
| 0.2  | 0.9798652  | 0.20271    |
| 0.4  | 0.9177710  | 0.42279    |
| 0.6  | 0.8080348  | 0.68414    |
| 0.8  | 0.6386093  | 1.02964    |
| 1.0  | 0.3843735  | 1.55741    |

Grafique este polinomio.

:::

**Solución**



# Ejercicio 9

::: {.callout-note title="Instrucción del ejercicio 9"}

Use el algoritmo de Diferencias Divididas para calcular el polinomio de interpolación de Lagrange $p(x)$ de cuarto grado para:

$$
f(x) = x^3 \sin(x)
$$

con nodos $x_0 = 1$, $x_1 = 2$, $x_2 = 3$, $x_3 = 4$ y $x_4 = 5$.

Grafique en un mismo plano $f(x)$ y $p(x)$ y luego imprima.

:::

**Solución**



# Ejercicio 10

::: {.callout-note title="Instrucción del ejercicio 10"}

Probar que los polinomios $L_k(x)$ vistos en clase se pueden expresar de la forma:

$$
L_k(x) = \frac{\psi(x)}{(x - x_k)\psi'(x_k)}
$$

donde:

$$
\psi(x) = \prod_{j=0}^n (x - x_j)
$$

y que por lo tanto el polinomio interpolante de Lagrange se puede expresar como:

$$
p(x) = \psi(x) \sum_{k=0}^n \frac{f(x_k)}{(x - x_k)\psi'(x_k)}.
$$

:::

**Solución**



# Ejercicio 11

::: {.callout-note title="Instrucción del ejercicio 11"}

Demostrar que si $f(x)$ es un polinomio de grado menor o igual a $n$, entonces el polinomio de grado menor o igual a $n$ que interpola $f(x)$ en $x_0, x_1, \ldots, x_n$ es el mismo $f(x)$.

:::

**Solución**



# Ejercicio 12

::: {.callout-note title="Instrucción del ejercicio 12"}

Usar el ejercicio anterior para probar que:

$$
\sum_{i=0}^n L_i(x) = 1
$$

:::

**Solución**

# Ejercicio 13

::: {.callout-note title="Instrucción del ejercicio 13"}

Para las siguientes funciones:

- $f(x)=3x^2\ln(x)+2x$ con nodos $x_0=1$, $x_1=1.5$, $x_2=2$, $x_3=2.5$ y $x_4=3$.
- $f(x)=x^2\sin(x)-3\cos(x)$ con nodos $x_0=1$, $x_1=2$, $x_2=3$, $x_3=4$ y $x_4=5$.
- $f(x)=x\cos(x)-2x^2+3x-1$ con nodos $x_0=1$, $x_1=2$, $x_2=3$, $x_3=4$ y $x_4=5$.

a) Encuentre el polinomio de interpolación de Lagrange $P^\star(x)$ en los nodos indicados, grafique $f(x)$ y $P^\star(x)$ en el mismo plano.

b) Encuentre el polinomio de interpolación usando Splines cúbicos $P^{\star\star}(x)$ en los nodos indicados, grafique $f(x)$ y $P^{\star\star}(x)$ en el mismo plano, luego imprima.

c) Encuentre el polinomio de interpolación de Hermite $P^{\star\star\star}(x)$ en los nodos indicados, grafique $f(x)$ y $P^{\star\star\star}(x)$ en el mismo plano.

d) Grafique $f(x)$, $P^\star(x)$, $P^{\star\star}(x)$ y $P^{\star\star\star}(x)$ en el mismo plano. ¿Qué se puede concluir?

:::

**Solución**



# Ejercicio 14

::: {.callout-note title="Instrucción del ejercicio 14"}

¿Existen $a,b,c,d$ y $e$ tal que la función:

$$
S(x)=
\begin{cases}
ax^3+x^2+cx, & -1\le x\le 0,\\[4pt]
bx^3+x^2+dx, & \ \ 0\le x\le 1
\end{cases}
$$

sea el spline cúbico natural que coincide con la función $f(x)=|x|$ en los nodos $-1,0,1$?

:::

**Solución**



# Ejercicio 15

::: {.callout-note title="Instrucción del ejercicio 15"}

Encuentre los valores de $a,b,c,d$ y $e$ tal que la función $S(x)$ es un spline cúbico natural:

$$
S(x)=
\begin{cases}
a+b(x-1)+c(x-1)^2+d(x-1)^3, & 0\le x\le 1,\\[4pt]
(x-1)^3+ex^2-1, & 1\le x\le 2.
\end{cases}
$$

:::

**Solución**



# Ejercicio 16

::: {.callout-note title="Instrucción del ejercicio 16"}

Encuentre los valores de $a,b,c$ y $d$ tal que la función $S(x)$ es un spline cúbico y cumple que
$\displaystyle \int_{0}^{2}\!\big[S''(x)\big]^2\,dx$ es mínimo (esta condición sustituye a la condición para ser spline natural o sujeto):

$$
S(x)=
\begin{cases}
3+x-9x^3, & 0\le x\le 1,\\[4pt]
a+b(x-1)+c(x-1)^2+d(x-1)^3, & 1\le x\le 2.
\end{cases}
$$

:::

**Solución**



# Ejercicio 17

::: {.callout-note title="Instrucción del ejercicio 17"}

El objetivo de este ejercicio es estudiar e implementar un algoritmo para **Aproximación discreta por mínimos cuadrados**. Para esto:

a) El problema en general es aproximar una tabla de datos $\{(x_i,y_i)\mid i=1,2,\ldots,m\}$ por un polinomio de grado $n<m-1$ denotado por
$$
P_n(x)=\sum_{k=0}^{n} a_k x^k.
$$
La idea es encontrar constantes $\{a_k\}_{k=0}^{n}$ tal que se minimice el error:
$$
E=\sum_{i=1}^{m}\big(y_i-P_n(x_i)\big)^2.
$$
Pruebe que este mínimo se alcanza en la solución del sistema de **ecuaciones normales** (n+1)×(n+1) para las incógnitas $\{a_k\}_{k=0}^{n}$ dado por:
$$
\sum_{k=0}^{n} a_k \sum_{i=1}^{m} x_i^{\,j+k}
\;=\;
\sum_{i=1}^{m} y_i x_i^{\,j},
\qquad j=0,1,2,\ldots,n.
$$

b) Dada una tabla de datos para $f$, escriba una función en **R** que permita generar el sistema de ecuaciones normales del inciso (a).

c) Luego escriba una función en **R** que encuentre los coeficientes del polinomio de mínimos cuadrados y luego lo grafique.

d) Construir la **aproximación de mínimos cuadrados de grado 3** para la siguiente tabla y **construir el gráfico**.

| $x_i$ | $y_i$   |
|:-----:|:-------:|
| 4.0   | 102.56  |
| 4.2   | 113.18  |
| 4.5   | 130.11  |
| 4.7   | 142.05  |
| 5.1   | 167.53  |
| 5.5   | 195.14  |
| 5.9   | 224.87  |
| 6.3   | 256.73  |
| 6.8   | 299.50  |
| 7.1   | 326.72  |

:::

**Solución**




# Ejercicio 18

::: {.callout-note title="Instrucción del ejercicio 18"}

El objetivo de este ejercicio es **generalizar la aproximación discreta por mínimos cuadrados**.  
Dada una función $f\in C[a,b]$, se requiere un polinomio $\tilde P_n(x)=\sum_{k=0}^{n} a_k x^k$ de manera tal que las constantes $\{a_k\}_{k=0}^{n}$ minimicen el error:

$$
E=\int_a^b \big(f(x)-\tilde P_n(x)\big)^2\,dx.
$$

Pruebe que este mínimo se alcanza en la solución del sistema de **$(n+1)$ ecuaciones normales** y $(n+1)$ incógnitas $\{a_k\}_{k=0}^{n}$ dado por:

$$
\sum_{k=0}^{n} a_k \int_a^b x^{j+k}\,dx \;=\; \int_a^b x^{j} f(x)\,dx,
\qquad j=0,1,2,\ldots,n.
\tag{2}
$$

a) Dada una función $f$ escriba una función en **R** que permita **generar el sistema de ecuaciones (2)**.

b) Luego escriba una función en **R** que **encuentre los coeficientes** del polinomio $\tilde P_n(x)$ y luego lo grafique.

c) Encuentre la **aproximación polinómica** $\tilde P_n(x)$ de grado $2$, $4$ y $6$ para $f(x)=\cos(\pi x)$ en el intervalo $[-1,1]$. Además, **construya los gráficos**.

:::

**Solución**



# Ejercicio 19

::: {.callout-note title="Instrucción del ejercicio 19"}

a) Demuestre que el **Polinomio de Hermite** visto en clase $H_{2n+1}(x)$ es **único**.  
*Sugerencia:* Suponga que existe otro polinomio $P(x)$ que cumple las condiciones de interpolación de Hermite y considere $D=H_{2n+1}(x)-P(x)$ y $D'$ en $x_0,x_1,\ldots,x_n$.

b) Demuestre que el **error absoluto** en este caso está dado por:

$$
\big|f(x)-H_{2n+1}(x)\big| \;=\;
\left|\frac{(x-x_0)^2\cdots(x-x_n)^2}{(2n+2)!}\, f^{(2n+2)}(\xi)\right|,
\quad \text{con } \xi\in(a,b) .
$$

**Sugerencia:** Use el mismo método que usamos para demostrar la fórmula del error absoluto en el caso de Lagrange, pero con:

$$
g(t)=f(t)-H_{2n+1}(t)\;-\;
\frac{(t-x_0)^2\cdots(t-x_n)^2}{(x-x_0)^2\cdots(x-x_n)^2}
\Big[f(x)-H_{2n+1}(x)\Big].
$$

:::

**Solución**
