---
title: "MA0501 – Tarea 5"
author: 
  - name: "Diego Alberto Vega Víquez - C38367" 
    email: "diegovv13@gmail.com"
  - name: "José Carlos Quintero Cedeño - C26152" 
    email: "jose.quinterocedeno@ucr.ac.cr"
  - name: "Gabriel Valverde Guzmán - C38060"
    email: "GABRIEL.VALVERDEGUZMAN@ucr.ac.cr"
date: today
lang: es
format:
  pdf:
    documentclass: article
    fontsize: 11pt
    linestretch: 1.3
    geometry:
      - top=2.5cm
      - bottom=2.5cm
      - left=2.5cm
      - right=2.5cm
      - headheight=15pt
      - footskip=1.25cm
    toc: true
    toc-depth: 1
    number-sections: false
    classoption:
      - oneside
      - titlepage 
    openany: true
    colorlinks: false   
    top-level-division: section
    include-in-header: 
      text: |
        \usepackage[most]{tcolorbox}
        \usepackage[hidelinks]{hyperref}
        \usepackage{setspace}
        \AtBeginDocument{\setstretch{1.0}} % ← interlineado
  html:
    code-annotations: hover
    toc: true
    toc-depth: 1
    toc-location: left
    toc_float: yes
    html-math-method: katex
    css: styles.css
    df_print: paged
    theme: flatly
    highlight: tango
    embed-resources: true
    page-layout: full
editor: 
  markdown: 
    wrap: 72
---

\newpage

# Ejercicio 1

::: {.callout-note title="Instrucción del ejercicio 1"}

Implemente en **R** los algoritmos de derivación numérica vistos en clase.  
Se deben implementar los siguientes:

- `Der2Puntos(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 2 puntos *)

- `Der3PuntosA(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 3 puntos - fórmula A *)

- `Der3PuntosB(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 3 puntos - fórmula B *)

- `Der5PuntosA(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 5 puntos - fórmula A *)

- `Der5PuntosB(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 5 puntos - fórmula B *)

:::

**Solución**  

```{r}
#| code-fold: true

Der2Puntos <- function(f, x_0, h) {
  return((f(x_0 + h) - f(x_0)) / h)
}

Der3PuntosA <- function(f, x_0, h) {
  return(((-3 / 2) * f(x_0) + 2 * f(x_0 + h) - (1 / 2) * f(x_0 + 2 * h)) /
           h)
}

Der3PuntosB <- function(f, x_0, h){
  return(((-1/2)*f(x_0 - h) + (1/2)*f(x_0 + h))/h)
}

Der5PuntosA <- function(f, x_0, h){
  return(( (-25/12)*f(x_0) + 4*f(x_0 + h) - 3*f(x_0 + 2*h) +
             (4/3)*f(x_0 + 3*h) - (1/4)*f(x_0 + 4*h) ) / h)
}

Der5PuntosB <- function(f, x_0, h){
  return(( f(x_0 - 2*h) - 8*f(x_0 - h) + 8*f(x_0 + h) - f(x_0 + 2*h) ) / (12*h))
}
```


# Ejercicio 2

::: {.callout-note title="Instrucción del ejercicio 2"}

Sea $f(x) = x^3 e^{x^2} - \sin x$.  
Para $h = 0.01$ y $h = 0.001$, aproxime $f'(2.19)$ usando todos los métodos implementados en el ejercicio 1.  
Compare con el valor exacto.  
¿Cuál es la mejor aproximación?

:::

**Solución**  

```{r}
#| code-fold: true

f <- function(x) (x^3)*exp(x^2) - sin(x)
df <- function(x) 3*(x^2)*exp(x^2) + 2*(x^4)*exp(x^2)-cos(x)
x <- 2.19
h1 <- 0.01
h2 <- 0.001

print("f'(2.19) con dos puntos")
Der2Puntos(f, x, h1)
Der2Puntos(f, x, h2)
df(x)

print("f'(2.19) con tres puntos")
Der3PuntosA(f, x, h1)
Der3PuntosA(f, x, h2)
Der3PuntosB(f, x, h1)
Der3PuntosB(f, x, h2)

print("f'(2.19) con 5 puntos")
Der5PuntosA(f, x, h1)
Der5PuntosA(f, x, h2)
Der5PuntosB(f, x, h1)
Der5PuntosB(f, x, h2)

```
Es claro que entre más pequeño el valor de h escogido, mejor va a ser la aproximación. Lo mismo sucede con la cantidad de nodos usados para estimar la derivada en el punto. 

# Ejercicio 3

::: {.callout-note title="Instrucción del ejercicio 3"}

Agregue al archivo anterior una función para la **Extrapolación de Richardson**,  
que permita trabajar con fórmulas del tipo $N(x_0, h)$.

:::

**Solución**  

```{r}
#| code-fold: true

Richardson <- function(N, x0, h, n){
  Q <- matrix(NA_real_, nrow = n, ncol = n)
  for (i in 1:n) {
    Q[i,1] <- N(x0, h/(2^(i - 1)))
  }
  for (i in 2:n) {
    for (j in 2:i) {
      Q[i,j] <- (4^(j-1)*Q[i,j-1] - Q[i-1,j-1])/(4^(j-1)-1)
    }
  }
  return(Q[n,n])
}
```


# Ejercicio 4

::: {.callout-note title="Instrucción del ejercicio 4"}

Se puede probar la siguiente **fórmula progresiva** para calcular derivadas:

$$
f'(x_0) = \frac{1}{h}\big[f(x_0 + h) - f(x_0)\big]
- \frac{h}{2} f''(x_0)
- \frac{h^2}{2} f'''(x_0)
+ O(h^3)
$$

Aplique **extrapolación de Richardson** para aproximar derivadas con la fórmula anterior.  
Luego, repita el ejercicio 2 usando este método.

:::

**Solución**  

```{r}
#| code-fold: true

formula <- function(f, d2f, d3f, x0, h){
  return((f(x0+h)-f(x0))/h - (h/2)*d2f(x0) - (h^2/2)*d3f(x0))
}

f <- function(x) (x^3)*exp(x^2) - sin(x)
df <- function(x) 3*(x^2)*exp(x^2) + 2*(x^4)*exp(x^2)-cos(x)
d2f <- function(x) 6*x*exp(x^2) + 14*x^3*exp(x^2)+4*x^5*exp(x^2)+sin(x)
d3f <- function(x) 6*exp(x^2)+54*x^2*exp(x^2)+48*x^4*exp(x^2)+8*x^6*exp(x^2)+cos(x)

Richardson(function(x, h) formula(f, d2f, d3f, x, h), 2.19, 0.01, 2)
Richardson(function(x, h) formula(f, d2f, d3f, x, h), 2.19, 0.001, 2)

```


# Ejercicio 5

::: {.callout-note title="Instrucción del ejercicio 5"}

Implemente en **R** los algoritmos de **integración numérica** vistos en clase.  
Se deben implementar los siguientes:

- `Trapecio(a, b)`  
  (* Calcula la integral de F de a hasta b, usando la regla del Trapecio *)

- `Simpson(a, b)`  
  (* Calcula la integral de F de a hasta b, usando la regla de Simpson *)

- `SimpsonCompuesta(a, b, m)`  
  (* Calcula la integral de F de a hasta b, usando la regla de Simpson Compuesta *)

- `Romberg(a, b, n)`  
  (* Calcula la integral de F de a hasta b, usando el método de Romberg *)

- `IntegralDobleSCT(a, b, n, m)`  
  (* Calcula la integral doble de F en regiones de tipo I usando Simpson Compuesto *)

:::

**Solución**  

```{r}
#| code-fold: true

Trapecio <- function(f, a, b){
  return((b-a)*(f(a) + f(b))/2)
}

Simpson <- function(f, a, b){
  return(((b-a)/6)*(f(a) + 4*f((a+b)/2)+f(b)))
}

SimpsonCompuesto <- function(f, a, b, m){
  h <- (b-a)/(2 * m)
  xi0 <- f(a)+f(b)
  xi1 <- 0 #suma de nodos impares
  xi2 <- 0 #suma de nodos pares
  for(j in 1:(2 * m - 1)){
    x <- a+j*h
    if(j%%2 == 0){
      xi2 <- xi2 + f(x)
    } else{
      xi1 <- xi1 + f(x)
    }
  }
  return((h/3)*(xi0 + 2*xi2 + 4*xi1))
}

Romberg <- function(f, a, b, n){
  Q <- matrix(NA_real_, nrow = n, ncol = n)
  h <- b-a
  Q[1,1] <- (h/2)*(f(a) + f(b))
  for (i in 2:n){
    suma <- 0
    for (k in 1:(2^(i-2))){
      suma <- suma + f(a + (k - 1/2)*h)
    }
    Q[i,1] <- 0.5*(Q[i-1,1] + h*suma)
    h <- h/2
  }
  
  for (i in 2:n) {
    for (j in 2:i) {
      Q[i,j] <- (4^(j-1)*Q[i,j-1] - Q[i-1,j-1])/(4^(j-1)-1)
    }
  }
  return(Q[n,n])
}

IntegralDobleSCT <- function(f, g1, g2, a, b, n, m){
  h <- (b-a)/(2*n)
  xi0 <- 0 # inicial + final
  xi1 <- 0 # impares
  xi2 <- 0 # pares
  for (i in 0:(2*n)) {
    xw <- a + i*h
    yi <- SimpsonCompuesto(function(y) f(xw, y), g1(xw), g2(xw), m)
    if(i == 0 || i == 2*n){
      xi0 <- xi0 + yi
    } else if(i %% 2 == 0){
      xi2 <- xi2 + yi
    } else {
      xi1 <- xi1 + yi
    }
  }
  return((h/3)*(xi0+4*xi1+2*xi2))
}
```



# Ejercicio 6

::: {.callout-note title="Instrucción del ejercicio 6"}

Calcule

$$
\int_0^{\pi} (4 + 2\sin x)\,dx
$$

mediante **todos los métodos programados arriba**  
(*excepto el último método de integración doble*).

:::

**Solución**  


# Ejercicio 7

::: {.callout-note title="Instrucción del ejercicio 7"}

Determine el valor de $n$ según las **cotas teóricas del error** para aproximar la integral:

$$
\int_0^{\pi} (8 + 5 \sin x)\,dx
$$

con **4 cifras significativas** mediante la **regla de Simpson Compuesta**.  
Calcule la integral con este valor de $n$.  
¿Es realmente el valor de $n$ necesario?

:::

**Solución**  

Note que el error del metodo de simpson compuesto viene dado por:

$$
|\dfrac{(b-a)^5\cdot f^{(4)}(\mu)}{2880\cdot n ^4}|
$$
De manera que si queremos acotarlo por $10^{-4}$, entonces hay que despejarlo tomando en cuenta lo siguiente:

Note que $f^{(4)} = 5\cdot\sin(x)\leq5$ y ademas $(b-a)^5 = \pi^5$

$$
\Rightarrow |\dfrac{(b-a)^5\cdot f^{(4)}(\mu)}{2880\cdot n ^4}|\leq |\dfrac{\pi^5\cdot 5}{2880\cdot n ^4}|\leq 10^{-4}\\
\Rightarrow n \geq (\dfrac{\pi^5\cdot 5}{2880\cdot 10^{-4}})^{1/4} \approx 8.5375 \\
\Rightarrow n \geq9
$$
Así pues, teóricamente, se requiere que n sea mayor o igual a 9. 

Por otra parte, note que con n = 8 se consigue que el error sea menor a $10^{-4}$:

```{r}
#| code-fold: true

integral_real <- integrate(function(x) 8 + 5*sin(x), 0, pi)$value
integral_estimada <- SimpsonCompuesto(function(x) 8 + 5*sin(x), 0, pi, 8)
abs(integral_real- integral_estimada)
```
Esto no ocurre si n = 7:
```{r}
#| code-fold: true

integral_real <- integrate(function(x) 8 + 5*sin(x), 0, pi)$value
integral_estimada <- SimpsonCompuesto(function(x) 8 + 5*sin(x), 0, pi, 7)
abs(integral_real- integral_estimada)
```



# Ejercicio 8

::: {.callout-note title="Instrucción del ejercicio 8"}

Calcule $\ln(2)$ usando:

$$
\ln(2) = \int_1^2 \frac{dx}{x}
$$

mediante la **regla de Simpson Compuesta**.  
¿Cuál es el menor valor de $n$ que garantiza **6 cifras significativas** en el cálculo de $\ln(2)$?

:::

**Solución**  
*(Determinación de $n$ mediante el error teórico de Simpson compuesta y comparación con el valor exacto de $\ln(2)$.)*



# Ejercicio 9

::: {.callout-note title="Instrucción del ejercicio 9"}

Use el procedimiento de **integrales dobles** para calcular el área limitada por la parábola  
$y = 4x - x^2$, el eje $X$, y la recta $y = -3x + 6$.  
Resuélvalo también usando **R** directamente.

:::

**Solución**  
*(Determinación de los puntos de intersección, límites de integración y cálculo del área mediante integración doble y verificación en R.)*



# Ejercicio 10

::: {.callout-note title="Instrucción del ejercicio 10"}

Usando el procedimiento de integración múltiple, calcule el volumen del sólido limitado por el paraboloide  

$$
z = 4 - x^2 - 2y^2
$$

y el plano $xy$.  
Resuélvalo también usando **R** directamente.

:::

**Solución**  

calculo con la funcion IntegralDobleSCT
```{r}
#| code-fold: true

root_safe <- function(x) pmax(0, 32 - 7*x^2)

volumen_estimado <- IntegralDobleSCT(function(x, y) 4 - x^2 - 2*y^2 - x*y, function(x) { (-x - sqrt(root_safe(x)))/4 }, function(x) { (-x + sqrt(root_safe(x)))/4 }, -4*sqrt(2)/sqrt(7), 4*sqrt(2)/sqrt(7), 100, 100)
volumen_estimado
```
Calculo directo con R
```{r}
#| code-fold: true

## Integrando: (4 - x^2 - 2y^2 - x*y)
f <- function(x, y) 4 - x^2 - 2*y^2 - x*y

## Límites en x como funciones de y
x_lower <- function(y) (-y - sqrt(16 - 7*y^2)) / 2
x_upper <- function(y) (-y + sqrt(16 - 7*y^2)) / 2

## Borde en y
y_min <- -4 / sqrt(7)
y_max <-  4 / sqrt(7)

## Integral interior en x, para un y dado
inner_x <- function(y) {
  ## Si y está fuera del dominio por redondeo numérico, devuelve 0
  if (7*y^2 > 16) return(0)
  integrate(function(x) f(x, y),
            lower = x_lower(y), upper = x_upper(y),
            rel.tol = 1e-10, abs.tol = 0)$value
}

## Integral exterior en y
V_dxdy <- integrate(function(y) Vectorize(inner_x)(y),
                    lower = y_min, upper = y_max,
                    rel.tol = 1e-9, abs.tol = 0)

V_dxdy$value

```

# Ejercicio 11

::: {.callout-note title="Instrucción del ejercicio 11"}

La **Regla del Trapecio Extendida** se presenta en el siguiente teorema:

> **Teorema:**  
> Sea $f \in C^2[a,b]$, con $h = (b - a)/n$ y $x_j = a + jh$ para cada $j = 0,1,\ldots,n$.  
> La regla del trapecio para $n$ subintervalos es:
>
> $$
> \int_a^b f(x)\,dx
> = \frac{h}{2}\left[f(a) + f(b) + 2\sum_{j=1}^{n-1} f(x_j)\right]
> - \frac{(b-a)h^2}{12} f''(\mu),
> \quad \text{para alguna } \mu \in [a,b].
> $$

(a) Pruebe el teorema anterior.  
(b) Escriba un algoritmo en pseudo-código para la **regla del trapecio extendida**.  
(c) Implemente en **R** la regla del trapecio extendida.

:::

**Solución**  

(a) Sea $f \in C^2[a,b]$ y subdividamos el intervalo en $n$ subintervalos de longitud $h = (b-a)/n$.

   En cada subintervalo $[x_j, x_{j+1}]$, aplicamos la regla del trapecio simple:

$$
\int_{x_j}^{x_{j+1}} f(x)\,dx = 
\frac{h}{2}\,[f(x_j) + f(x_{j+1})] - \frac{h^3}{12} f''(\xi_j),
\quad \xi_j \in [x_j,x_{j+1}].
$$

   Sumando para $j=0,\ldots,n-1$:

$$
\int_a^b f(x)\,dx = 
\sum_{j=0}^{n-1} \int_{x_j}^{x_{j+1}} f(x)\,dx =
\frac{h}{2}\Big[f(a)+f(b) + 2\sum_{j=1}^{n-1} f(x_j)\Big]
- \frac{h^3}{12}\sum_{j=0}^{n-1} f''(\xi_j).
$$

   Por el **teorema del valor medio para integrales**, existe $\mu \in [a,b]$ tal que:

$$
\sum_{j=0}^{n-1} f''(\xi_j) = n f''(\mu).
$$

   Sustituyendo $n = \frac{b-a}{h}$, obtenemos el término de error global:

$$
E(f) = -\frac{(b-a)h^2}{12}f''(\mu),
$$

   \hfill $\blacksquare$

(b) **Pseudo-código de la Regla del Trapecio Extendida**

```{text}
#| codecode-fold: true
Algoritmo Trapecio_Extendido(f, a, b, n)
  # Calcula ∫_a^b f(x) dx usando la regla del trapecio extendida
  Entrada:
      f(x): función continua
      a, b: límites de integración
      n: número de subintervalos
  Salida:
      Aproximación de la integral

  h ← (b - a) / n
  suma ← f(a) + f(b)

  Para j desde 1 hasta n-1 hacer
      xj ← a + j * h
      suma ← suma + 2 * f(xj)
  Fin Para

  integral ← (h / 2) * suma
  Retornar integral
Fin Algoritmo
```

(c) **Regla del trapecio extendida en R**
```{r}
#| code-fold: true

TrapecioExtendido <- function(f, a, b, n) {
  h <- (b - a) / n
  suma <- f(a) + f(b)

  for (j in 1:(n - 1)) {
    xj <- a + j * h
    suma <- suma + 2 * f(xj)
  }

  I <- (h / 2) * suma
  return(I)
}
```


# Ejercicio 12

::: {.callout-note title="Instrucción del ejercicio 12"}

Calcule:

$$
\int_0^2 x^2 e^{-x^2}\,dx
$$

usando la **regla del trapecio extendida** con $n = 8$.

:::

**Solución**  
*(Cálculo numérico de la integral y comparación con el valor de referencia obtenido por software simbólico.)*



# Ejercicio 13

::: {.callout-note title="Instrucción del ejercicio 13"}

Sea $f$ definida por:

$$
f(x) = 
\begin{cases}
x^3 + 1, & 0 \le x \le 2,\\[0.5em]
2x + 5, & 2 < x \le 6.
\end{cases}
$$

**(a)** Aproxime $\int_0^6 f(x)\,dx$ usando la **regla del trapecio extendida**.  
**(b)** Aproxime $\int_0^6 f(x)\,dx$ usando la **regla de Simpson compuesta**.  
**(c)** Determine cuál resultado es más preciso.

:::

**Solución**  

```{r}
#| code-fold: true

f <- function(x){
  if(0 <= x & x <= 2){
    return(x^3 + 1)
  } else if(2 < x & x <= 6){
    return(2*x + 5)
  } else{
    return(NULL)
  }
}
```


a)
```{r}
#| code-fold: true

tr <- TrapecioExtendido(f, 0, 6, 10)
tr
```
b)
```{r}
#| code-fold: true

si <- SimpsonCompuesto(f, 0, 6, 10)
si
```
c)
```{r}
#| code-fold: true

valor_real <- integrate(function(x) x^3 + 1, 0, 2)$value + integrate(function(x) 2*x + 5, 2, 6)$value
valor_real
```
error absoluto con trapecio:
```{r}
#| code-fold: true

abs(tr - valor_real)
```
error absoluto con simpson:
```{r}
#| code-fold: true

abs(si - valor_real)
```
En este caso, el resultado obtenido con el metodo de Simpson Compuesto es más preciso, entonces es mejor.


# Ejercicio 14

::: {.callout-note title="Instrucción del ejercicio 14"}

Escriba un **algoritmo en pseudo-código** para calcular **integrales dobles tipo I** basado en la **Regla del Trapecio Extendida**.  
Luego, agregue este algoritmo al módulo de integración numérica implementado anteriormente.

:::

**Solución**  

```{text}
Algoritmo Trapecio_Extendido_Doble(f, a, b, c, d, nx, ny)
  # Calcula ∫_{x=a}^{b} ∫_{y=c}^{d} f(x, y) dy dx
  # usando la Regla del Trapecio Extendida en ambas direcciones

  Entrada:
      f(x, y): función continua en [a,b]×[c,d]
      a, b : límites en x
      c, d : límites en y
      nx   : número de subintervalos en x
      ny   : número de subintervalos en y

  Salida:
      Aproximación de la integral doble

  h_x ← (b - a) / nx
  h_y ← (d - c) / ny
  suma ← 0

  Para i desde 0 hasta nx:
      x_i ← a + i * h_x
      Para j desde 0 hasta ny:
          y_j ← c + j * h_y
          peso ← 1
          Si (i = 0 ó i = nx) → peso ← peso / 2
          Si (j = 0 ó j = ny) → peso ← peso / 2
          suma ← suma + peso * f(x_i, y_j)
      Fin Para
  Fin Para

  integral ← h_x * h_y * suma
  Retornar integral
Fin Algoritmo
```

```{r}
#| code-fold: true
# Regla del Trapecio Extendida para integrales dobles tipo I
trapecio_doble <- function(f, a, b, c, d, nx, ny) {
  hx <- (b - a) / nx
  hy <- (d - c) / ny
  suma <- 0

  for (i in 0:nx) {
    x <- a + i * hx
    for (j in 0:ny) {
      y <- c + j * hy
      peso <- 1

      if (i == 0 || i == nx) peso <- peso / 2
      if (j == 0 || j == ny) peso <- peso / 2

      suma <- suma + peso * f(x, y)
    }
  }

  I <- hx * hy * suma
  return(I)
}
```


```{r}
# Ejemplo de uso:
f <- function(x, y) x^2 + y^2  # función ejemplo
resultado <- trapecio_doble(f, 0, 1, 0, 1, nx = 10, ny = 10)
cat("Aproximación de la integral doble:", resultado, "\n")
```


# Ejercicio 15

::: {.callout-note title="Instrucción del ejercicio 15"}

Repita los ejercicios 9 y 10 usando el algoritmo desarrollado en el ejercicio anterior.

:::

**Solución**  
*(Aplicación del nuevo algoritmo de integración doble a los casos geométricos definidos en los ejercicios 9 y 10.)*

# Ejercicio 16

::: {.callout-note title="Instrucción del ejercicio 16"}

Sea

$$
f(x) = \int_0^x \cos(t^2)\,dt.
$$

(a) Interpole $f(x)$ con nodos $x_0 = 0$, $x_1 = \frac{\pi}{2}$, $x_2 = \pi$,  
$x_3 = \frac{3\pi}{2}$, $x_4 = 2\pi$, $x_5 = \frac{5\pi}{2}$, $x_6 = 3\pi$,  
usando alguno de los métodos vistos en el curso.  

*Sugerencia:* Recuerde que $\int \cos(t^2)\,dt$ no puede calcularse en términos de funciones elementales.

(b) Grafique el polinomio $p(x)$ y la función $f(x)$ en un mismo plano.

(c) Dé dos razones por las cuales **a priori** se sabe que la interpolación anterior para $f(x)$ es “mala”.

:::

**Solución**  

a y b)
```{r}
#| code-fold: true
#| warning: false
library(tidyverse)

neville <- function(nodos, valores, x) {
  stopifnot(is.numeric(nodos),
            is.numeric(valores),
            length(nodos) == length(valores))
  n <- length(nodos)
  Q <- matrix(NA_real_, nrow = n, ncol = n)
  
  # Columna inicial con valores de Y
  Q[, 1] <-  valores
  
  # Construccion de la tabla de Neville
  for (i in 2:n) {
    for (j in 2:i) {
      numerador <- ((x - nodos[i - j + 1]) * Q[i, j - 1] - (x - nodos[i]) * Q[i -
                                                                                1, j - 1])
      denominador <- nodos[i] - nodos[i - j + 1]
      Q[i, j] <-  numerador / denominador
    }
  }
  return(list(valor = Q[n, n], tabla = Q))
}

graficar.polinomio <- function(nodos,
                               a,
                               b,
                               metodo,
                               f = NULL,
                               valores = NULL,
                               df = NULL,
                               derivadas.clamped = NULL) {
  stopifnot(is.numeric(nodos), length(nodos) >= 2)
  # Validación: exactamente uno de f o valores
  if (is.null(f) == is.null(valores)) {
    stop("Debe proveer exactamente uno: 'f' (función) o 'valores' (numérico).")
  }
  # Obtener valores en nodos según el caso
  if (!is.null(f)) {
    stopifnot(is.function(f))
    valores_nodos <- f(nodos)
  } else {
    stopifnot(is.numeric(valores), length(valores) == length(nodos))
    valores_nodos <- valores
  }
  
  # Derivadas (opcional). Acepta función o vector numérico.
  derivadas_nodos <- NULL
  if (!is.null(df)) {
    if (is.function(df)) {
      derivadas_nodos <- df(nodos)
    } else if (is.numeric(df)) {
      stopifnot(length(df) == length(nodos))
      derivadas_nodos <- df
    } else {
      stop("`df` debe ser función o vector numérico de derivadas en los nodos.")
    }
  }
  
  # Wrapper vectorizado para el método (con o sin derivadas)
  if (!is.null(derivadas_nodos)) {
    H <- function(x)
      vapply(x, function(xx)
        metodo(nodos, valores_nodos, derivadas_nodos, xx)$valor, numeric(1))
  } else {
    if(is.null(derivadas.clamped)){
      H <- function(x)
        vapply(x, function(xx)
          metodo(nodos, valores_nodos, xx)$valor, numeric(1))
    } else{
      H <- function(x)
        vapply(x, function(xx)
          spline.sujeto(nodos, valores_nodos, derivadas.clamped, xx)$valor, numeric(1))
    }
  }
  
  # Malla y data frames
  xi <- seq(a, b, length.out = 400)
  df_plot <- data.frame(x  = xi,
                        Hx = H(xi),
                        fx = if (!is.null(f))
                          f(xi)
                        else
                          NA_real_)
  df_nodos <- data.frame(x = nodos, y = valores_nodos)
  
  # Gráfico: con f (dos curvas) o solo interpolación
  p <- ggplot(df_plot, aes(x = x))
  if (!is.null(f)) {
    p <- p +
      geom_line(aes(y = fx, color = "Original"), linewidth = 1) +
      geom_line(aes(y = Hx, color = "Interpolación"),
                linewidth = 1,
                linetype = "dashed") +
      scale_color_manual(values = c(
        "Original" = "blue",
        "Interpolación" = "red"
      ))
  } else {
    p <- p +
      geom_line(aes(y = Hx, color = "Interpolación"), linewidth = 1) +
      scale_color_manual(values = c("Interpolación" = "red"))
  }
  p +
    geom_point(
      data = df_nodos,
      aes(x = x, y = y),
      shape = 21,
      size = 3,
      fill = "white"
    ) +
    labs(title = paste0("Interpolación por ", deparse(substitute(metodo))), y = "Valor", color = "Serie") +
    theme_minimal(base_size = 14)
}
```

```{r}
#| code-fold: true
nodos <- c(0, pi/2, pi, 3*pi/2, 2*pi, 5*pi/2, 3*pi)
imagenes <- numeric(6)
for (i in 1:7) {
  imagenes[i] <- integrate(function(x) cos(x^2), 0, nodos[i])$value
}

f_scalar <- function(x) integrate(function(y) cos(y^2), lower = 0, upper = x)$value
f <- Vectorize(f_scalar)

graficar.polinomio(nodos, 0, 3*pi, neville, f = f)

```
c)

Se puede saber desde antes de hacer la gráfica que la interpolación no va a ser buena por dos motivos.

Primero, los puntos que se eligieron están bastante separados entre sí dentro del intervalo. Eso hace que el polinomio tenga que “rellenar” grandes espacios sin información, y al hacerlo termina alejándose bastante de la forma real de la función.

Segundo, la función original cambia de forma muy rápido, sube y baja muchas veces. Como el polinomio tiene que pasar por todos los puntos, trata de imitar esas variaciones y termina haciendo curvas exageradas que no representan bien el comportamiento verdadero.

# Ejercicio 17

::: {.callout-note title="Instrucción del ejercicio 17"}

Determine $a, b, c$ en la fórmula de cuadratura:

$$
\int_{-1}^{1} f(x)\,dx = a f(-\alpha) + b f(0) + c f(\alpha) + \mathcal{E}(f)
$$

en función de $\alpha$, tal que tenga una **exactitud algebraica igual a 3**, por lo menos.

:::

**Solución**  

Por simetría del intervalo y de los nodos $(-\alpha,0,\alpha)$, debe cumplirse que los pesos de los puntos simétricos sean iguales:
$$a=c.$$
Así, la fórmula queda:
$$
\int_{-1}^{1} f(x)\,dx = a[f(-\alpha)+f(\alpha)] + b f(0) + \mathcal{E}(f).
$$

Queremos que la fórmula sea **exacta para todos los polinomios de grado $\le$ 3**.

1. Para $f(x)=1$:
$$
\int_{-1}^{1}1\,dx=2,\qquad a(1+1)+b(1)=2a+b=2.
$$
Por tanto,
\begin{equation}
2a+b=2 \tag{1}
\end{equation}

2. Para $f(x)=x$:
$$
\int_{-1}^{1}x\,dx=0,\qquad a(-\alpha+\alpha)+b(0)=0,
$$
lo cual se cumple automáticamente, como se esperaba por simetría.

3. Para $f(x)=x^2$:
$$
\int_{-1}^{1}x^2\,dx=\frac{2}{3},\qquad a(\alpha^2+\alpha^2)+b(0^2)=2a\alpha^2.
$$
Por tanto,
\begin{equation}
2a\alpha^2=\frac{2}{3} \quad\Rightarrow\quad a=\frac{1}{3\alpha^2}. \tag{2}
\end{equation}

4. Para $f(x)=x^3$:
$$
\int_{-1}^{1}x^3\,dx=0,\qquad a(-\alpha^3+\alpha^3)+b(0^3)=0,
$$
lo cual también se cumple automáticamente.  
Por tanto, la regla será exacta hasta grado 3.

5. Sustituyendo (2) en (1):
$$
2\left(\frac{1}{3\alpha^2}\right) + b = 2 
\quad\Rightarrow\quad b = 2 - \frac{2}{3\alpha^2}.
$$


Los coeficientes son:
$$
\boxed{
a=c=\frac{1}{3\alpha^2}, \qquad b=2-\frac{2}{3\alpha^2}.
}
$$

Esta regla tiene **exactitud algebraica igual a 3** para todo $\alpha>0$ y se reduce a una familia de cuadraturas simétricas de tres puntos en $[-1,1]$.

# Ejercicio 18

::: {.callout-note title="Instrucción del ejercicio 18"}

Repita el ejercicio anterior pero con **exactitud algebraica igual a 5**.

:::

**Solución**  
*(Derivación del sistema extendido para los polinomios de grado hasta 5 y cálculo de los coeficientes.)*



# Ejercicio 19

::: {.callout-note title="Instrucción del ejercicio 19"}

Demuestre la **regla de Simpson** a partir de la fórmula de cuadratura

$$
\int_{x_0}^{x_2} f(x)\,dx = a_0 f(x_0) + a_1 f(x_1) + a_2 f(x_2) + \mathcal{E}(f)
$$

usando el hecho de que la fórmula de Simpson tiene **exactitud algebraica igual a 3**.

:::

**Solución**  
*(Derivación paso a paso de los coeficientes $a_0$, $a_1$, $a_2$ mediante el ajuste de los momentos exactos de monomios de grado 0 a 3.)*

Queremos determinar los coeficientes $a_0$, $a_1$, $a_2$ de la cuadratura tal que sean los que establece la regla de simpson, asumiendo exactitud algebraica 3. 

Tome nodos igualmente espaciados: $x_1 = \dfrac{x_1 + x_2}{2}$ y longitud total $2h = x_2 - x_0$

Queremos que la formula sea exacta en $f(x) = 1, x, x^2, x^3$

1- Para $f(x) = 1$

$$\int_{x_0}^{x_2} 1dx = 2h = a_0 + a_1 + a_2$$

2- Para $f(x) = x$

$$\int_{x_0}^{x_2} x dx = \dfrac{{x_2}^2 - {x_0}^2}{2} = 2x_1h = a_0x_0 + a_1x_1 + a_2x_2$$

$$\Rightarrow 2x_1h = x_1(a_0 + a_1 + a_2) + h(a_2 - a_0)$$

Como ya sabemos que $a_0 + a_1 + a_2 = 2h$, entonces debe cumplirse que $a_2 - a_0 = 0 \Rightarrow a_2 = a_1$

3- Para $f(x) = x^2$

$$\int_{x_0}^{x_2}x^2dx = \dfrac{{x_2}^3 - {x_0}^3}{3} = \dfrac{2h}{3}(3{x_1}^2 + h^2)$$
y
$$a_0x_0^2 + a_1x_1^2 + a_2x_2^2 = a_0(x_1 - h)^2 + a_1x_1^2 + a_2(x_1 + h)^2$$
Reemplazando $a_0 = a_2$

$$= a_0[(x_1 - h)^2 + (x_1 + h)^2] + a_1x_1^2 = 2a_0(x_1^2 + h^2) + a_1x_1^2$$

Igualando y usando $a_0 + a_1 +a_2 = 2h \Rightarrow a_1 = 2h - 2a_0$:

$$\dfrac{2h}{3}(3x_1^2 + h^2) = 2a_0(x_1^2 + h^2) + (2h - 2a_0)x_1^2$$

Simplificando:

$$\dfrac{2h}{3}(3x_1^2 + h^2) = 2hx_1^2 - 2a_0h^2$$

Despejando $a_0$:

$$
a_0 = \dfrac{h}{3} \\
\Rightarrow a_1 = 2h -2a_0 = \dfrac{4h}{3}
$$
Asi pues, podemos ver que

$$\int_{x_0}^{x_1}f(x) \approx \dfrac{h}{3}(f(x_0) + 4f(x_1) + f(x_2))$$

lo cual es justamente la regla de simpson.

\hfill $\blacksquare$

# Ejercicio 20

::: {.callout-note title="Instrucción del ejercicio 20"}

Demuestre que existe una constante positiva $c$ tal que la fórmula de cuadratura

$$
\int_{-1/2}^{1/2} f(x)\,dx = \frac{1}{3}\,[f(-c) + f(0) + f(c)] + \mathcal{E}(f)
$$

tiene **exactitud algebraica igual a 3**.

:::

**Solución**  


Buscamos $c>0$ tal que la regla
$$Q[f]=\tfrac{1}{3}\,[\,f(-c)+f(0)+f(c)\,]$$
reproduzca exactamente los momentos de $\displaystyle I[f]=\int_{-1/2}^{1/2} f(x)\,dx$ para todos los polinomios de grado $\le 3$.

Por simetría del intervalo y de los nodos $(-c,0,c)$:

- Para $p(x)=1$,
$$I[p]=\int_{-1/2}^{1/2}1\,dx=1,\qquad Q[p]=\tfrac{1}{3}(1+1+1)=1.$$

- Para $p(x)=x$ y $p(x)=x^3$,
$$I[p]=0\quad (\text{funciones impares}),\qquad 
Q[p]=\tfrac{1}{3}\big((-c)^k+0+c^k\big)=0\quad (k=1,3).$$

- Para $p(x)=x^2$,
$$I[p]=\int_{-1/2}^{1/2}x^2\,dx=\left.\frac{x^3}{3}\right|_{-1/2}^{1/2}=\frac{1}{12},$$
mientras que
$$Q[p]=\tfrac{1}{3}\big(c^2+0+c^2\big)=\frac{2c^2}{3}.$$
Exigiendo $Q[p]=I[p]$ se obtiene
$$\frac{2c^2}{3}=\frac{1}{12}\quad\Longrightarrow\quad c^2=\frac{1}{8}\;\;\Rightarrow\;\; c=\frac{1}{2\sqrt{2}} \; (>0).$$

Con este valor de $c$, la regla es exacta para $1,x,x^2,x^3$, por lo que su **exactitud algebraica es 3**. En consecuencia, el término de error $\mathcal{E}(f)$ se anula para todo polinomio de grado $\le 3$ (y, para $f\in C^4$, es de orden $O(\|f^{(4)}\|)$ por el teorema de Peano para reglas de cuadratura).
\hfill $\blacksquare$



# Ejercicio 21

::: {.callout-note title="Instrucción del ejercicio 21"}

Determine las constantes $a$ y $b$ tal que la fórmula de cuadratura

$$
\int_0^{\infty} e^{-x} f(x)\,dx = \frac{1}{4} [a f(b) + b f(a)] + \mathcal{E}(f)
$$

tenga **exactitud algebraica igual a 3**, por lo menos.

:::

**Solución**  
*(Empleo de la función peso $e^{-x}$, desarrollo de los momentos de Laguerre y resolución del sistema de condiciones para $a$ y $b$.)*



# Ejercicio 22

::: {.callout-note title="Instrucción del ejercicio 22"}

Demuestre que existen constantes $c_1 \in [a,b]$ y $c_2 \in [a,b]$ tal que la fórmula de cuadratura

$$
\int_a^b f(x)\,dx = \frac{b-a}{2} \, [f(c_1) + f(c_2)] + \mathcal{E}(f)
$$

tiene **exactitud algebraica igual a 3**, por lo menos.

:::

**Solución**  

Buscamos constantes $c_1$ y $c_2$ en $[a,b]$ tales que la fórmula de cuadratura

$$
\int_a^b f(x)\,dx = \frac{b-a}{2}\,[f(c_1) + f(c_2)]
$$

tenga exactitud algebraica igual a $3$, es decir, que sea exacta para los polinomios $f(x) = 1$, $f(x) = x$, $f(x) = x^2$ y $f(x) = x^3$.

 1. Caso $f(x) = 1$

$$
\int_a^b 1\,dx = b - a = \frac{b-a}{2}(1 + 1)
$$

Por lo tanto, la fórmula es exacta para funciones constantes.

 2. Caso $f(x) = x$

$$
\int_a^b x\,dx = \frac{b^2 - a^2}{2} = \frac{b-a}{2}(c_1 + c_2)
$$

De aquí se obtiene la relación

$$
c_1 + c_2 = a + b
$$

 3. Caso $f(x) = x^2$

$$
\int_a^b x^2\,dx = \frac{b^3 - a^3}{3} = \frac{b-a}{2}(c_1^2 + c_2^2)
$$

Simplificando,

$$
c_1^2 + c_2^2 = \frac{2}{3}(a^2 + ab + b^2)
$$

Definimos las sumas simétricas

$$
S_1 = c_1 + c_2 = a + b, \quad S_2 = c_1 c_2
$$

Entonces,

$$
S_1^2 - 2S_2 = \frac{2}{3}(a^2 + ab + b^2)
$$

De donde

$$
S_2 = \frac{a^2 + 4ab + b^2}{6}
$$

 4. Cálculo de los puntos $c_1$ y $c_2$

Después de desarrollar un poco el sistema de ecuaciones dado por los casos 2 y 3, se nota que los puntos $c_1$ y $c_2$ son las raíces del polinomio cuadrático

$$
t^2 - S_1 t + S_2 = 0
$$

es decir,

$$
c_{1,2} = \frac{S_1 \pm \sqrt{S_1^2 - 4S_2}}{2}
$$

Sustituyendo los valores de $S_1$ y $S_2$,

$$
S_1^2 - 4S_2 = (a+b)^2 - \frac{4(a^2 + 4ab + b^2)}{6} = \frac{(b - a)^2}{3}
$$

Por tanto,

$$
\boxed{
c_1 = \frac{a+b}{2} - \frac{b-a}{2\sqrt{3}}, \quad
c_2 = \frac{a+b}{2} + \frac{b-a}{2\sqrt{3}}
}
$$

Como $0 < 1/\sqrt{3} < 1$, se cumple que $c_1$ y $c_2$ pertenecen al intervalo $[a,b]$.

 5. Caso $f(x) = x^3$

Usando la identidad

$$
c_1^3 + c_2^3 = S_1^3 - 3S_1S_2
$$

y sustituyendo los valores de $S_1$ y $S_2$, se verifica que la igualdad también se cumple para $f(x) = x^3$.

Por tanto, existen $c_1$ y $c_2$ en $[a,b]$ tales que

$$
\int_a^b f(x)\,dx = \frac{b-a}{2}[f(c_1) + f(c_2)] + E(f)
$$

y la fórmula tiene exactitud algebraica igual a $3$.  

# Ejercicio 23

::: {.callout-note title="Instrucción del ejercicio 23"}

Usando **integración numérica**, escriba un procedimiento en **R** que permita obtener para una función dada $f(x)$ su **polinomio trigonométrico $S_n(x)$**,  
es decir, una **aproximación a su Serie de Fourier**.

:::



::: {.callout-note title="Instrucción del inciso (a)"}

Si se definen:

$$
\phi_0(x) = \frac{1}{\sqrt{2\pi}},
$$

$$
\phi_k(x) = \frac{1}{\sqrt{\pi}} \cos(kx), \quad k = 1, 2, \ldots, n,
$$

$$
\phi_{n+k}(x) = \frac{1}{\sqrt{\pi}} \sin(kx), \quad k = 1, 2, \ldots, n-1.
$$

Pruebe que el conjunto  

$$
B = \{\phi_0, \phi_1, \ldots, \phi_{2n-1}\}
$$

es **ortogonal** con el producto interno integral en el intervalo $[-\pi, \pi]$.  

Dada $f \in C[-\pi, \pi]$, su polinomio trigonométrico $S_n(x)$ se define como:

$$
S_n(x) := \sum_{k=0}^{2n-1} a_k \, \phi_k(x),
$$

donde

$$
a_k = \int_{-\pi}^{\pi} f(x)\phi_k(x)\,dx, \quad k = 0, 1, \ldots, 2n-1.
$$

El límite:

$$
\lim_{n \to \infty} S_n(x) = \lim_{n \to \infty} \sum_{k=0}^{2n-1} a_k \phi_k(x)
$$

se denomina **Serie de Fourier** de $f$.

:::

**Solución (a)**  

Usaremos, para $r,s\in\mathbb{Z}_{\ge 0}$,
$$
\cos(rx)\cos(sx)=\tfrac12\big[\cos((r-s)x)+\cos((r+s)x)\big],\\
\sin(rx)\sin(sx)=\tfrac12\big[\cos((r-s)x)-\cos((r+s)x)\big],\\
\sin(rx)\cos(sx)=\tfrac12\big[\sin((r+s)x)+\sin((r-s)x)\big].
$$
Además, para $m\in\mathbb{Z}\setminus\{0\}$ se cumple
$$
\int_{-\pi}^{\pi}\cos(mx)\,dx=0,\qquad \int_{-\pi}^{\pi}\sin(mx)\,dx=0,
$$
y $\int_{-\pi}^{\pi}1\,dx=2\pi$.

** Productos con $\phi_0$ **

- Con sí misma:
$$
\langle \phi_0,\phi_0\rangle=\int_{-\pi}^{\pi}\frac{1}{2\pi}\,dx=\frac{1}{2\pi}\cdot 2\pi=1.
$$

- Con $\phi_k=\frac{1}{\sqrt{\pi}}\cos(kx)$ ($k\ge 1$):
$$
\langle \phi_0,\phi_k\rangle=\frac{1}{\sqrt{2\pi\,\pi}}\int_{-\pi}^{\pi}\cos(kx)\,dx=0.
$$

- Con $\phi_{n+k}=\frac{1}{\sqrt{\pi}}\sin(kx)$ ($k\ge 1$):
$$
\langle \phi_0,\phi_{n+k}\rangle=\frac{1}{\sqrt{2\pi\,\pi}}\int_{-\pi}^{\pi}\sin(kx)\,dx=0.
$$

Por lo tanto, $\phi_0$ es ortogonal a todas las demás y tiene norma $1$.

**Coseno con coseno**

Para $k,\ell\ge 1$,
$$
\langle \phi_k,\phi_\ell\rangle
=\frac{1}{\pi}\int_{-\pi}^{\pi}\cos(kx)\cos(\ell x)\,dx
=\frac{1}{2\pi}\int_{-\pi}^{\pi}\big[\cos((k-\ell)x)+\cos((k+\ell)x)\big]\,dx.
$$

- Si $k\ne \ell$, ambas integrales son $0$, así que $\langle \phi_k,\phi_\ell\rangle=0$.

- Si $k=\ell$, queda
$$
\langle \phi_k,\phi_k\rangle
=\frac{1}{2\pi}\int_{-\pi}^{\pi}\big[1+\cos(2kx)\big]\,dx
=\frac{1}{2\pi}\big[2\pi+0\big]=1.
$$
**Seno con seno**

Para $k,\ell\ge 1$,
$$
\langle \phi_{n+k},\phi_{n+\ell}\rangle
=\frac{1}{\pi}\int_{-\pi}^{\pi}\sin(kx)\sin(\ell x)\,dx
=\frac{1}{2\pi}\int_{-\pi}^{\pi}\big[\cos((k-\ell)x)-\cos((k+\ell)x)\big]\,dx.
$$

- Si $k\ne \ell$, el valor es $0$.

- Si $k=\ell$, entonces
$$
\langle \phi_{n+k},\phi_{n+k}\rangle
=\frac{1}{2\pi}\int_{-\pi}^{\pi}\big[1-\cos(2kx)\big]\,dx
=\frac{1}{2\pi}\big[2\pi-0\big]=1.
$$

**Seno con coseno**


Para $k,\ell\ge 1$,
$$
\langle \phi_{n+k},\phi_\ell\rangle
=\frac{1}{\pi}\int_{-\pi}^{\pi}\sin(kx)\cos(\ell x)\,dx
=\frac{1}{2\pi}\int_{-\pi}^{\pi}\big[\sin((k+\ell)x)+\sin((k-\ell)x)\big]\,dx=0.
$$

De los productos con $\phi_0$ y el seno con coseno se sigue que
$$
\langle \phi_i,\phi_j\rangle=
\begin{cases}
1,& i=j,\\[2mm]
0,& i\ne j,
\end{cases}
$$
por lo que $B=\{\phi_0,\phi_1,\ldots,\phi_{2n-1}\}$ es no solo **ortogonal** sino **ortonormal** en $L^2([-\pi,\pi])$ con el producto interno dado. \hfill $\blacksquare$

::: {.callout-note title="Instrucción del inciso (b)"}

Usando alguno de los métodos de integración numérica programados anteriormente,  
escriba una función en **R** para calcular:

$$
a_k = \int_{-\pi}^{\pi} f(x)\phi_k(x)\,dx, \quad \text{para cada } k = 0, 1, \ldots, 2n-1.
$$

:::

**Solución (b)**  


```{r}
#| code-fold: true

coef.fourier <- function(f, k, tipo = "coseno") {

  integrando <- switch(
    tipo,
    "constante" = function(x) f(x),
    "coseno"    = function(x) f(x) * cos(k * x),
    "seno"      = function(x) f(x) * sin(k * x),
    stop("El parámetro 'tipo' debe ser 'constante', 'coseno' o 'seno'.")
  )
  
  # Cálculo del coeficiente según el tipo
  if (tipo == "constante") {
    return((1 / (2 * pi)) * SimpsonCompuesto(integrando, -pi, pi, 200))
  } else {
    return((1 / pi) * SimpsonCompuesto(integrando, -pi, pi, 200))
  }
}
```


::: {.callout-note title="Instrucción del inciso (c)"}

Programe una función en **R** para calcular la suma:

$$
S(n, x) = \sum_{k=0}^{2n-1} a_k \phi_k(x).
$$

:::

**Solución (c)**  

```{r}
#| code-fold: true

serie.fourier <- function(f, n, x) {
  a0 <- coef.fourier(f, 0, tipo = "constante")
  suma <- a0
  for (k in 1:n) {
    a_k <- coef.fourier(f, k, tipo = "coseno")
    b_k <- coef.fourier(f, k, tipo = "seno")
    suma <- suma + a_k * cos(k * x) + b_k * sin(k * x)
  }
  return(suma)
}
```

::: {.callout-note title="Instrucción del inciso (d)"}

Con el programa anterior, encontrar $S_n(x)$ para  
$n = 3, 4, 5, 6, 7, 8$  
para la función:

$$
f(x) = 
\begin{cases}
-1, & -\pi < x < 0, \\[0.3em]
1, & 0 < x < \pi.
\end{cases}
$$

Luego grafique $f(x)$ y $S_n(x)$ en un mismo plano para $n = 3, 4, 5, 6, 7, 8$.

:::

**Solución (d)**  

```{r}
#| include: false
graficar <- function(funciones, a, b, c = NULL, d = NULL, n = 400,
                     nombres = NULL, titulo = "Gráfico de funciones") {
  # Verificaciones básicas
  stopifnot(is.numeric(a), is.numeric(b), a < b)
  
  # Si se pasa solo una función, la convertimos en lista
  if (is.function(funciones)) {
    funciones <- list(funciones)
  }
  
  # Si no se dan nombres, los generamos automáticamente
  if (is.null(nombres)) {
    nombres <- paste0("f", seq_along(funciones))
  } else if (length(nombres) != length(funciones)) {
    stop("El número de nombres debe coincidir con el número de funciones.")
  }
  
  # Crear secuencia de puntos
  x <- seq(a, b, length.out = n)
  
  # Evaluar cada función y combinar en un solo data frame
  lista_datos <- lapply(seq_along(funciones), function(i) {
    y <- tryCatch(funciones[[i]](x),
                  error = function(e) rep(NA, length(x)))
    data.frame(x = x, y = y, funcion = nombres[i])
  })
  
  datos <- do.call(rbind, lista_datos)
  
  # Crear el gráfico base
  p <- ggplot(datos, aes(x = x, y = y, color = funcion)) +
    geom_line(linewidth = 1) +
    labs(
      title = titulo,
      x = "x",
      y = "f(x)",
      color = "Función"
    ) +
    theme_minimal(base_size = 14) +
    theme(legend.position = "bottom")
  
  # Aplicar límites del eje Y si se proporcionan
  if (!is.null(c) && !is.null(d)) {
    stopifnot(is.numeric(c), is.numeric(d), c < d)
    p <- p + coord_cartesian(ylim = c(c, d))
  }
  
  return(p)
}
```


```{r}
#| code-fold: true

funcion.prueba <- function(x) {
  if (-pi <= x && x < 0) {
    return(-1)
  } else if (0 <= x && x <= pi) {
    return(1)
  } else {
    return(NA)
  }
}

funcion.prueba <- Vectorize(funcion.prueba)

graficar(list(function(x) funcion.prueba(x), function(x) serie.fourier(funcion.prueba, 3, x), function(x) serie.fourier(funcion.prueba, 4, x), function(x) serie.fourier(funcion.prueba, 5, x), function(x) serie.fourier(funcion.prueba, 6, x), function(x) serie.fourier(funcion.prueba, 7, x), function(x) serie.fourier(funcion.prueba, 8, x)), -pi, pi, -2, 2)
```
En este grafico, f1 representa la funcion original, y de f2 a f7 son las series de fourier incrementando n de 3 a 8

