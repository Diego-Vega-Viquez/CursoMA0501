---
title: "MA0501 – Tarea 5"
author: 
  - name: "Diego Alberto Vega Víquez - C38367" 
    email: "diegovv13@gmail.com"
  - name: "José Carlos Quintero Cedeño - C26152" 
    email: "jose.quinterocedeno@ucr.ac.cr"
  - name: "Gabriel Valverde Guzmán - C38060"
    email: "GABRIEL.VALVERDEGUZMAN@ucr.ac.cr"
date: today
lang: es
format:
  pdf:
    documentclass: article
    fontsize: 11pt
    linestretch: 1.3
    geometry:
      - top=2.5cm
      - bottom=2.5cm
      - left=2.5cm
      - right=2.5cm
      - headheight=15pt
      - footskip=1.25cm
    toc: true
    toc-depth: 1
    number-sections: false
    classoption:
      - oneside
      - titlepage 
    openany: true
    colorlinks: false   
    top-level-division: section
    include-in-header: 
      text: |
        \usepackage[most]{tcolorbox}
        \usepackage[hidelinks]{hyperref}
        \usepackage{setspace}
        \AtBeginDocument{\setstretch{1.0}} % ← interlineado
  html:
    code-annotations: hover
    toc: true
    toc-depth: 1
    toc-location: left
    toc_float: yes
    html-math-method: katex
    css: styles.css
    df_print: paged
    theme: flatly
    highlight: tango
    embed-resources: true
    page-layout: full
editor: 
  markdown: 
    wrap: 72
---

\newpage

# Ejercicio 1

::: {.callout-note title="Instrucción del ejercicio 1"}

Implemente en **R** los algoritmos de derivación numérica vistos en clase.  
Se deben implementar los siguientes:

- `Der2Puntos(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 2 puntos *)

- `Der3PuntosA(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 3 puntos - fórmula A *)

- `Der3PuntosB(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 3 puntos - fórmula B *)

- `Der5PuntosA(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 5 puntos - fórmula A *)

- `Der5PuntosB(X0, h)`  
  (* Calcula la derivada de F usando la fórmula de 5 puntos - fórmula B *)

:::

**Solución**  
*(Implementación en R de las cinco funciones para derivación numérica)*

```{r}
Der2Puntos <- function(f, x_0, h) {
  return((f(x_0 + h) - f(x_0)) / h)
}

Der3PuntosA <- function(f, x_0, h) {
  return(((-3 / 2) * f(x_0) + 2 * f(x_0 + h) - (1 / 2) * f(x_0 + 2 * h)) /
           h)
}

Der3PuntosB <- function(f, x_0, h){
  return(((-1/2)*f(x_0 - h) + (1/2)*f(x_0 + h))/h)
}

Der5PuntosA <- function(f, x_0, h){
  return(( (-25/12)*f(x_0) + 4*f(x_0 + h) - 3*f(x_0 + 2*h) +
             (4/3)*f(x_0 + 3*h) - (1/4)*f(x_0 + 4*h) ) / h)
}

Der5PuntosB <- function(f, x_0, h){
  return(( f(x_0 - 2*h) - 8*f(x_0 - h) + 8*f(x_0 + h) - f(x_0 + 2*h) ) / (12*h))
}
```


# Ejercicio 2

::: {.callout-note title="Instrucción del ejercicio 2"}

Sea $f(x) = x^3 e^{x^2} - \sin x$.  
Para $h = 0.01$ y $h = 0.001$, aproxime $f'(2.19)$ usando todos los métodos implementados en el ejercicio 1.  
Compare con el valor exacto.  
¿Cuál es la mejor aproximación?

:::

**Solución**  
*(Cálculo de $f'(2.19)$ mediante las cinco fórmulas de derivación y comparación con la derivada analítica exacta.)*

```{r}
f <- function(x) (x^3)*exp(x^2) - sin(x)
df <- function(x) 3*(x^2)*exp(x^2) + 2*(x^4)*exp(x^2)-cos(x)
x <- 2.19
h1 <- 0.01
h2 <- 0.001

print("f'(2.19) con dos puntos")
Der2Puntos(f, x, h1)
Der2Puntos(f, x, h2)
df(x)

print("f'(2.19) con tres puntos")
Der3PuntosA(f, x, h1)
Der3PuntosA(f, x, h2)
Der3PuntosB(f, x, h1)
Der3PuntosB(f, x, h2)

print("f'(2.19) con 5 puntos")
Der5PuntosA(f, x, h1)
Der5PuntosA(f, x, h2)
Der5PuntosB(f, x, h1)
Der5PuntosB(f, x, h2)

```
Es claro que entre más pequeño el valor de h escogido, mejor va a ser la aproximación. Lo mismo sucede con la cantidad de nodos usados para estimar la derivada en el punto. 

# Ejercicio 3

::: {.callout-note title="Instrucción del ejercicio 3"}

Agregue al archivo anterior una función para la **Extrapolación de Richardson**,  
que permita trabajar con fórmulas del tipo $N(x_0, h)$.

:::

**Solución**  
*(Implementación de una función general para aplicar extrapolación de Richardson a derivadas numéricas.)*

```{r}
Richardson <- function(N, x0, h, n){
  Q <- matrix(NA_real_, nrow = n, ncol = n)
  for (i in 1:n) {
    Q[i,1] <- N(x0, h/(2^(i - 1)))
  }
  for (i in 2:n) {
    for (j in 2:i) {
      Q[i,j] <- (4^(j-1)*Q[i,j-1] - Q[i-1,j-1])/(4^(j-1)-1)
    }
  }
  return(Q[n,n])
}
```


# Ejercicio 4

::: {.callout-note title="Instrucción del ejercicio 4"}

Se puede probar la siguiente **fórmula progresiva** para calcular derivadas:

$$
f'(x_0) = \frac{1}{h}\big[f(x_0 + h) - f(x_0)\big]
- \frac{h}{2} f''(x_0)
- \frac{h^2}{2} f'''(x_0)
+ O(h^3)
$$

Aplique **extrapolación de Richardson** para aproximar derivadas con la fórmula anterior.  
Luego, repita el ejercicio 2 usando este método.

:::

**Solución**  
*(Implementación de la fórmula progresiva con extrapolación de Richardson aplicada al caso de $f'(2.19)$.)*

```{r}
formula <- function(f, d2f, d3f, x0, h){
  return((f(x0+h)-f(x0))/h - (h/2)*d2f(x0) - (h^2/2)*d3f(x0))
}

f <- function(x) (x^3)*exp(x^2) - sin(x)
df <- function(x) 3*(x^2)*exp(x^2) + 2*(x^4)*exp(x^2)-cos(x)
d2f <- function(x) 6*x*exp(x^2) + 14*x^3*exp(x^2)+4*x^5*exp(x^2)+sin(x)
d3f <- function(x) 6*exp(x^2)+54*x^2*exp(x^2)+48*x^4*exp(x^2)+8*x^6*exp(x^2)+cos(x)

Richardson(function(x, h) formula(f, d2f, d3f, x, h), 2.19, 0.01, 2)
Richardson(function(x, h) formula(f, d2f, d3f, x, h), 2.19, 0.001, 2)

```


# Ejercicio 5

::: {.callout-note title="Instrucción del ejercicio 5"}

Implemente en **R** los algoritmos de **integración numérica** vistos en clase.  
Se deben implementar los siguientes:

- `Trapecio(a, b)`  
  (* Calcula la integral de F de a hasta b, usando la regla del Trapecio *)

- `Simpson(a, b)`  
  (* Calcula la integral de F de a hasta b, usando la regla de Simpson *)

- `SimpsonCompuesta(a, b, m)`  
  (* Calcula la integral de F de a hasta b, usando la regla de Simpson Compuesta *)

- `Romberg(a, b, n)`  
  (* Calcula la integral de F de a hasta b, usando el método de Romberg *)

- `IntegralDobleSCT(a, b, n, m)`  
  (* Calcula la integral doble de F en regiones de tipo I usando Simpson Compuesto *)

:::

**Solución**  
*(Implementación de los cinco métodos de integración numérica en R.)*

```{r}
Trapecio <- function(f, a, b){
  return((b-a)*(f(a) + f(b))/2)
}

Simpson <- function(f, a, b){
  return(((b-a)/6)*(f(a) + 4*f((a+b)/2)+f(b)))
}

SimpsonCompuesto <- function(f, a, b, m){
  h <- (b-a)/(2 * m)
  xi0 <- f(a)+f(b)
  xi1 <- 0 #suma de nodos impares
  xi2 <- 0 #suma de nodos pares
  for(j in 1:(2 * m - 1)){
    x <- a+j*h
    if(j%%2 == 0){
      xi2 <- xi2 + f(x)
    } else{
      xi1 <- xi1 + f(x)
    }
  }
  return((h/3)*(xi0 + 2*xi2 + 4*xi1))
}

Romberg <- function(f, a, b, n){
  Q <- matrix(NA_real_, nrow = n, ncol = n)
  h <- b-a
  Q[1,1] <- (h/2)*(f(a) + f(b))
  for (i in 2:n){
    suma <- 0
    for (k in 1:(2^(i-2))){
      suma <- suma + f(a + (k - 1/2)*h)
    }
    Q[i,1] <- 0.5*(Q[i-1,1] + h*suma)
    h <- h/2
  }
  
  for (i in 2:n) {
    for (j in 2:i) {
      Q[i,j] <- (4^(j-1)*Q[i,j-1] - Q[i-1,j-1])/(4^(j-1)-1)
    }
  }
  return(Q[n,n])
}

IntegralDobleSCT <- function(f, g1, g2, a, b, n, m){
  h <- (b-a)/(2*n)
  xi0 <- 0 # inicial + final
  xi1 <- 0 # impares
  xi2 <- 0 # pares
  for (i in 0:(2*n)) {
    xw <- a + i*h
    yi <- SimpsonCompuesto(function(y) f(xw, y), g1(xw), g2(xw), m)
    if(i == 0 || i == 2*n){
      xi0 <- xi0 + yi
    } else if(i %% 2 == 0){
      xi2 <- xi2 + yi
    } else {
      xi1 <- xi1 + yi
    }
  }
  return((h/3)*(xi0+4*xi1+2*xi2))
}
```



# Ejercicio 6

::: {.callout-note title="Instrucción del ejercicio 6"}

Calcule

$$
\int_0^{\pi} (4 + 2\sin x)\,dx
$$

mediante **todos los métodos programados arriba**  
(*excepto el último método de integración doble*).

:::

**Solución**  
*(Evaluación de la integral con Trapecio, Simpson, Simpson Compuesto y Romberg;  
comparación con el valor analítico exacto $= 4\pi$.)*

# Ejercicio 7

::: {.callout-note title="Instrucción del ejercicio 7"}

Determine el valor de $n$ según las **cotas teóricas del error** para aproximar la integral:

$$
\int_0^{\pi} (8 + 5 \sin x)\,dx
$$

con **4 cifras significativas** mediante la **regla de Simpson Compuesta**.  
Calcule la integral con este valor de $n$.  
¿Es realmente el valor de $n$ necesario?

:::

**Solución**  
*(Cálculo teórico del error en Simpson compuesta, estimación de $n$, verificación numérica y comparación del error real con el teórico.)*

Note que el error del metodo de simpson compuesto viene dado por:

$$
|\dfrac{(b-a)^5\cdot f^{(4)}(\mu)}{2880\cdot n ^4}|
$$
De manera que si queremos acotarlo por $10^{-4}$, entonces hay que despejarlo tomando en cuenta lo siguiente:

Note que $f^{(4)} = 5\cdot\sin(x)\leq5$ y ademas $(b-a)^5 = \pi^5$

$$
\Rightarrow |\dfrac{(b-a)^5\cdot f^{(4)}(\mu)}{2880\cdot n ^4}|\leq |\dfrac{\pi^5\cdot 5}{2880\cdot n ^4}|\leq 10^{-4}\\
\Rightarrow n \geq (\dfrac{\pi^5\cdot 5}{2880\cdot 10^{-4}})^{1/4} \approx 8.5375 \\
\Rightarrow n \geq9
$$
Así pues, teóricamente, se requiere que n sea mayor o igual a 9. 

Por otra parte, note que con n = 8 se consigue que el error sea menor a $10^{-4}$:

```{r}
integral_real <- integrate(function(x) 8 + 5*sin(x), 0, pi)$value
integral_estimada <- SimpsonCompuesto(function(x) 8 + 5*sin(x), 0, pi, 8)
abs(integral_real- integral_estimada)
```
Esto no ocurre si n = 7:
```{r}
integral_real <- integrate(function(x) 8 + 5*sin(x), 0, pi)$value
integral_estimada <- SimpsonCompuesto(function(x) 8 + 5*sin(x), 0, pi, 7)
abs(integral_real- integral_estimada)
```



# Ejercicio 8

::: {.callout-note title="Instrucción del ejercicio 8"}

Calcule $\ln(2)$ usando:

$$
\ln(2) = \int_1^2 \frac{dx}{x}
$$

mediante la **regla de Simpson Compuesta**.  
¿Cuál es el menor valor de $n$ que garantiza **6 cifras significativas** en el cálculo de $\ln(2)$?

:::

**Solución**  
*(Determinación de $n$ mediante el error teórico de Simpson compuesta y comparación con el valor exacto de $\ln(2)$.)*



# Ejercicio 9

::: {.callout-note title="Instrucción del ejercicio 9"}

Use el procedimiento de **integrales dobles** para calcular el área limitada por la parábola  
$y = 4x - x^2$, el eje $X$, y la recta $y = -3x + 6$.  
Resuélvalo también usando **R** directamente.

:::

**Solución**  
*(Determinación de los puntos de intersección, límites de integración y cálculo del área mediante integración doble y verificación en R.)*



# Ejercicio 10

::: {.callout-note title="Instrucción del ejercicio 10"}

Usando el procedimiento de integración múltiple, calcule el volumen del sólido limitado por el paraboloide  

$$
z = 4 - x^2 - 2y^2
$$

y el plano $xy$.  
Resuélvalo también usando **R** directamente.

:::

**Solución**  
*(Definición del dominio de integración, cálculo del volumen analítico y numérico en R.)*

calculo con la funcion IntegralDobleSCT
```{r}
root_safe <- function(x) pmax(0, 32 - 7*x^2)

volumen_estimado <- IntegralDobleSCT(function(x, y) 4 - x^2 - 2*y^2 - x*y, function(x) { (-x - sqrt(root_safe(x)))/4 }, function(x) { (-x + sqrt(root_safe(x)))/4 }, -4*sqrt(2)/sqrt(7), 4*sqrt(2)/sqrt(7), 100, 100)
volumen_estimado
```
Calculo directo con R
```{r}
## Integrando: (4 - x^2 - 2y^2 - x*y)
f <- function(x, y) 4 - x^2 - 2*y^2 - x*y

## Límites en x como funciones de y
x_lower <- function(y) (-y - sqrt(16 - 7*y^2)) / 2
x_upper <- function(y) (-y + sqrt(16 - 7*y^2)) / 2

## Borde en y
y_min <- -4 / sqrt(7)
y_max <-  4 / sqrt(7)

## Integral interior en x, para un y dado
inner_x <- function(y) {
  ## Si y está fuera del dominio por redondeo numérico, devuelve 0
  if (7*y^2 > 16) return(0)
  integrate(function(x) f(x, y),
            lower = x_lower(y), upper = x_upper(y),
            rel.tol = 1e-10, abs.tol = 0)$value
}

## Integral exterior en y
V_dxdy <- integrate(function(y) Vectorize(inner_x)(y),
                    lower = y_min, upper = y_max,
                    rel.tol = 1e-9, abs.tol = 0)

V_dxdy$value

```

# Ejercicio 11

::: {.callout-note title="Instrucción del ejercicio 11"}

La **Regla del Trapecio Extendida** se presenta en el siguiente teorema:

> **Teorema:**  
> Sea $f \in C^2[a,b]$, con $h = (b - a)/n$ y $x_j = a + jh$ para cada $j = 0,1,\ldots,n$.  
> La regla del trapecio para $n$ subintervalos es:
>
> $$
> \int_a^b f(x)\,dx
> = \frac{h}{2}\left[f(a) + f(b) + 2\sum_{j=1}^{n-1} f(x_j)\right]
> - \frac{(b-a)h^2}{12} f''(\mu),
> \quad \text{para alguna } \mu \in [a,b].
> $$

**(a)** Pruebe el teorema anterior.  
**(b)** Escriba un algoritmo en pseudo-código para la **regla del trapecio extendida**.  
**(c)** Implemente en **R** la regla del trapecio extendida.

:::

**Solución**  
*(Demostración teórica del teorema, desarrollo del pseudo-código y ejemplo de implementación en R.)*

**Regla del trapecio extendida**
```{r}
TrapecioExtendido <- function(f, a, b, n){
  h <- (b-a)/n
  suma <- 0
  for(i in 1:(n-1)){
    suma <- suma + f(a + i*h)
  }
  
  return((h/2)*(f(a) + f(b) + 2*suma))
}
```


# Ejercicio 12

::: {.callout-note title="Instrucción del ejercicio 12"}

Calcule:

$$
\int_0^2 x^2 e^{-x^2}\,dx
$$

usando la **regla del trapecio extendida** con $n = 8$.

:::

**Solución**  
*(Cálculo numérico de la integral y comparación con el valor de referencia obtenido por software simbólico.)*



# Ejercicio 13

::: {.callout-note title="Instrucción del ejercicio 13"}

Sea $f$ definida por:

$$
f(x) = 
\begin{cases}
x^3 + 1, & 0 \le x \le 2,\\[0.5em]
2x + 5, & 2 < x \le 6.
\end{cases}
$$

**(a)** Aproxime $\int_0^6 f(x)\,dx$ usando la **regla del trapecio extendida**.  
**(b)** Aproxime $\int_0^6 f(x)\,dx$ usando la **regla de Simpson compuesta**.  
**(c)** Determine cuál resultado es más preciso.

:::

**Solución**  
*(Evaluación de ambas integrales con los métodos solicitados y comparación de errores relativos.)*
```{r}
f <- function(x){
  if(0 <= x & x <= 2){
    return(x^3 + 1)
  } else if(2 < x & x <= 6){
    return(2*x + 5)
  } else{
    return(NULL)
  }
}
```


a)
```{r}
tr <- TrapecioExtendido(f, 0, 6, 10)
tr
```
b)
```{r}
si <- SimpsonCompuesto(f, 0, 6, 10)
si
```
c)
```{r}
valor_real <- integrate(function(x) x^3 + 1, 0, 2)$value + integrate(function(x) 2*x + 5, 2, 6)$value
valor_real
```
error absoluto con trapecio:
```{r}
abs(tr - valor_real)
```
error absoluto con simpson:
```{r}
abs(si - valor_real)
```
En este caso, el resultado obtenido con el metodo de Simpson Compuesto es más preciso, entonces es mejor.


# Ejercicio 14

::: {.callout-note title="Instrucción del ejercicio 14"}

Escriba un **algoritmo en pseudo-código** para calcular **integrales dobles tipo I** basado en la **Regla del Trapecio Extendida**.  
Luego, agregue este algoritmo al módulo de integración numérica implementado anteriormente.

:::

**Solución**  
*(Esquema de pseudo-código del algoritmo generalizado a doble integración y adaptación al código previo.)*



# Ejercicio 15

::: {.callout-note title="Instrucción del ejercicio 15"}

Repita los ejercicios 9 y 10 usando el algoritmo desarrollado en el ejercicio anterior.

:::

**Solución**  
*(Aplicación del nuevo algoritmo de integración doble a los casos geométricos definidos en los ejercicios 9 y 10.)*

# Ejercicio 16

::: {.callout-note title="Instrucción del ejercicio 16"}

Sea

$$
f(x) = \int_0^x \cos(t^2)\,dt.
$$

(a) Interpole $f(x)$ con nodos $x_0 = 0$, $x_1 = \frac{\pi}{2}$, $x_2 = \pi$,  
$x_3 = \frac{3\pi}{2}$, $x_4 = 2\pi$, $x_5 = \frac{5\pi}{2}$, $x_6 = 3\pi$,  
usando alguno de los métodos vistos en el curso.  

*Sugerencia:* Recuerde que $\int \cos(t^2)\,dt$ no puede calcularse en términos de funciones elementales.

(b) Grafique el polinomio $p(x)$ y la función $f(x)$ en un mismo plano.

(c) Dé dos razones por las cuales **a priori** se sabe que la interpolación anterior para $f(x)$ es “mala”.

:::

**Solución**  
*(Construcción de los nodos y valores de $f(x)$ mediante integración numérica, obtención del polinomio interpolante y análisis de la oscilación tipo Runge.)*

a y b)
```{r}
#| code-fold: true
#| warning: false
library(tidyverse)

neville <- function(nodos, valores, x) {
  stopifnot(is.numeric(nodos),
            is.numeric(valores),
            length(nodos) == length(valores))
  n <- length(nodos)
  Q <- matrix(NA_real_, nrow = n, ncol = n)
  
  # Columna inicial con valores de Y
  Q[, 1] <-  valores
  
  # Construccion de la tabla de Neville
  for (i in 2:n) {
    for (j in 2:i) {
      numerador <- ((x - nodos[i - j + 1]) * Q[i, j - 1] - (x - nodos[i]) * Q[i -
                                                                                1, j - 1])
      denominador <- nodos[i] - nodos[i - j + 1]
      Q[i, j] <-  numerador / denominador
    }
  }
  return(list(valor = Q[n, n], tabla = Q))
}

graficar.polinomio <- function(nodos,
                               a,
                               b,
                               metodo,
                               f = NULL,
                               valores = NULL,
                               df = NULL,
                               derivadas.clamped = NULL) {
  stopifnot(is.numeric(nodos), length(nodos) >= 2)
  # Validación: exactamente uno de f o valores
  if (is.null(f) == is.null(valores)) {
    stop("Debe proveer exactamente uno: 'f' (función) o 'valores' (numérico).")
  }
  # Obtener valores en nodos según el caso
  if (!is.null(f)) {
    stopifnot(is.function(f))
    valores_nodos <- f(nodos)
  } else {
    stopifnot(is.numeric(valores), length(valores) == length(nodos))
    valores_nodos <- valores
  }
  
  # Derivadas (opcional). Acepta función o vector numérico.
  derivadas_nodos <- NULL
  if (!is.null(df)) {
    if (is.function(df)) {
      derivadas_nodos <- df(nodos)
    } else if (is.numeric(df)) {
      stopifnot(length(df) == length(nodos))
      derivadas_nodos <- df
    } else {
      stop("`df` debe ser función o vector numérico de derivadas en los nodos.")
    }
  }
  
  # Wrapper vectorizado para el método (con o sin derivadas)
  if (!is.null(derivadas_nodos)) {
    H <- function(x)
      vapply(x, function(xx)
        metodo(nodos, valores_nodos, derivadas_nodos, xx)$valor, numeric(1))
  } else {
    if(is.null(derivadas.clamped)){
      H <- function(x)
        vapply(x, function(xx)
          metodo(nodos, valores_nodos, xx)$valor, numeric(1))
    } else{
      H <- function(x)
        vapply(x, function(xx)
          spline.sujeto(nodos, valores_nodos, derivadas.clamped, xx)$valor, numeric(1))
    }
  }
  
  # Malla y data frames
  xi <- seq(a, b, length.out = 400)
  df_plot <- data.frame(x  = xi,
                        Hx = H(xi),
                        fx = if (!is.null(f))
                          f(xi)
                        else
                          NA_real_)
  df_nodos <- data.frame(x = nodos, y = valores_nodos)
  
  # Gráfico: con f (dos curvas) o solo interpolación
  p <- ggplot(df_plot, aes(x = x))
  if (!is.null(f)) {
    p <- p +
      geom_line(aes(y = fx, color = "Original"), linewidth = 1) +
      geom_line(aes(y = Hx, color = "Interpolación"),
                linewidth = 1,
                linetype = "dashed") +
      scale_color_manual(values = c(
        "Original" = "blue",
        "Interpolación" = "red"
      ))
  } else {
    p <- p +
      geom_line(aes(y = Hx, color = "Interpolación"), linewidth = 1) +
      scale_color_manual(values = c("Interpolación" = "red"))
  }
  p +
    geom_point(
      data = df_nodos,
      aes(x = x, y = y),
      shape = 21,
      size = 3,
      fill = "white"
    ) +
    labs(title = paste0("Interpolación por ", deparse(substitute(metodo))), y = "Valor", color = "Serie") +
    theme_minimal(base_size = 14)
}
```

```{r}
nodos <- c(0, pi/2, pi, 3*pi/2, 2*pi, 5*pi/2, 3*pi)
imagenes <- numeric(6)
for (i in 1:7) {
  imagenes[i] <- integrate(function(x) cos(x^2), 0, nodos[i])$value
}

f_scalar <- function(x) integrate(function(y) cos(y^2), lower = 0, upper = x)$value
f <- Vectorize(f_scalar)

graficar.polinomio(nodos, 0, 3*pi, neville, f = f)

```
c)

Se puede saber desde antes de hacer la gráfica que la interpolación no va a ser buena por dos motivos.

Primero, los puntos que se eligieron están bastante separados entre sí dentro del intervalo. Eso hace que el polinomio tenga que “rellenar” grandes espacios sin información, y al hacerlo termina alejándose bastante de la forma real de la función.

Segundo, la función original cambia de forma muy rápido, sube y baja muchas veces. Como el polinomio tiene que pasar por todos los puntos, trata de imitar esas variaciones y termina haciendo curvas exageradas que no representan bien el comportamiento verdadero.

# Ejercicio 17

::: {.callout-note title="Instrucción del ejercicio 17"}

Determine $a, b, c$ en la fórmula de cuadratura:

$$
\int_{-1}^{1} f(x)\,dx = a f(-\alpha) + b f(0) + c f(\alpha) + \mathcal{E}(f)
$$

en función de $\alpha$, tal que tenga una **exactitud algebraica igual a 3**, por lo menos.

:::

**Solución**  
*(Desarrollo del sistema de ecuaciones a partir de la condición de exactitud algebraica y resolución para $a, b, c$ en términos de $\alpha$.)*



# Ejercicio 18

::: {.callout-note title="Instrucción del ejercicio 18"}

Repita el ejercicio anterior pero con **exactitud algebraica igual a 5**.

:::

**Solución**  
*(Derivación del sistema extendido para los polinomios de grado hasta 5 y cálculo de los coeficientes.)*



# Ejercicio 19

::: {.callout-note title="Instrucción del ejercicio 19"}

Demuestre la **regla de Simpson** a partir de la fórmula de cuadratura

$$
\int_{x_0}^{x_2} f(x)\,dx = a_0 f(x_0) + a_1 f(x_1) + a_2 f(x_2) + \mathcal{E}(f)
$$

usando el hecho de que la fórmula de Simpson tiene **exactitud algebraica igual a 3**.

:::

**Solución**  
*(Derivación paso a paso de los coeficientes $a_0$, $a_1$, $a_2$ mediante el ajuste de los momentos exactos de monomios de grado 0 a 3.)*

Queremos determinar los coeficientes $a_0$, $a_1$, $a_2$ de la cuadratura tal que sean los que establece la regla de simpson, asumiendo exactitud algebraica 3. 

Tome nodos igualmente espaciados: $x_1 = \dfrac{x_1 + x_2}{2}$ y longitud total $2h = x_2 - x_0$

Queremos que la formula sea exacta en $f(x) = 1, x, x^2, x^3$

1- Para $f(x) = 1$

$\int_{x_0}^{x_2} 1dx = 2h = a_0 + a_1 + a_2$

2- Para $f(x) = x$

$\int_{x_0}^{x_2} x dx = \dfrac{{x_2}^2 - {x_0}^2}{2} = 2x_1h = a_0x_0 + a_1x_1 + a_2x_2$

$\Rightarrow 2x_1h = x_1(a_0 + a_1 + a_2) + h(a_2 - a_0)$

Como ya sabemos que $a_0 + a_1 + a_2 = 2h$, entonces debe cumplirse que $a_2 - a_0 = 0 \Rightarrow a_2 = a_1$

3- Para $f(x) = x^2$

$\int_{x_0}^{x_2}x^2dx = \dfrac{{x_2}^3 - {x_0}^3}{3} = \dfrac{2h}{3}(3{x_1}^2 + h^2)$
y
$a_0x_0^2 + a_1x_1^2 + a_2x_2^2 = a_0(x_1 - h)^2 + a_1x_1^2 + a_2(x_1 + h)^2$
Reemplazando $a_0 = a_2$

$= a_0[(x_1 - h)^2 + (x_1 + h)^2] + a_1x_1^2 = 2a_0(x_1^2 + h^2) + a_1x_1^2$

Igualando y usando $a_0 + a_1 +a_2 = 2h \Rightarrow a_1 = 2h - 2a_0$:

$\dfrac{2h}{3}(3x_1^2 + h^2) = 2a_0(x_1^2 + h^2) + (2h - 2a_0)x_1^2$

Simplificando:

$\dfrac{2h}{3}(3x_1^2 + h^2) = 2hx_1^2 - 2a_0h^2$

Despejando $a_0$:

$$
a_0 = \dfrac{h}{3} \\
\Rightarrow a_1 = 2h -2a_0 = \dfrac{4h}{3}
$$
Asi pues, podemos ver que

$\int_{x_0}^{x_1}f(x) \approx \dfrac{h}{3}(f(x_0) + 4f(x_1) + f(x_2))$

lo cual es justamente la regla de simpson.

# Ejercicio 20

::: {.callout-note title="Instrucción del ejercicio 20"}

Demuestre que existe una constante positiva $c$ tal que la fórmula de cuadratura

$$
\int_{-1/2}^{1/2} f(x)\,dx = \frac{1}{3}\,[f(-c) + f(0) + f(c)] + \mathcal{E}(f)
$$

tiene **exactitud algebraica igual a 3**.

:::

**Solución**  
*(Verificación de la exactitud algebraica mediante evaluación de la fórmula para $f(x) = 1, x, x^2, x^3$ y determinación de la constante $c$ que satisface las condiciones de simetría y momento.)*



# Ejercicio 21

::: {.callout-note title="Instrucción del ejercicio 21"}

Determine las constantes $a$ y $b$ tal que la fórmula de cuadratura

$$
\int_0^{\infty} e^{-x} f(x)\,dx = \frac{1}{4} [a f(b) + b f(a)] + \mathcal{E}(f)
$$

tenga **exactitud algebraica igual a 3**, por lo menos.

:::

**Solución**  
*(Empleo de la función peso $e^{-x}$, desarrollo de los momentos de Laguerre y resolución del sistema de condiciones para $a$ y $b$.)*



# Ejercicio 22

::: {.callout-note title="Instrucción del ejercicio 22"}

Demuestre que existen constantes $c_1 \in [a,b]$ y $c_2 \in [a,b]$ tal que la fórmula de cuadratura

$$
\int_a^b f(x)\,dx = \frac{b-a}{2} \, [f(c_1) + f(c_2)] + \mathcal{E}(f)
$$

tiene **exactitud algebraica igual a 3**, por lo menos.

:::

**Solución**  

Buscamos constantes $c_1$ y $c_2$ en $[a,b]$ tales que la fórmula de cuadratura

$$
\int_a^b f(x)\,dx = \frac{b-a}{2}\,[f(c_1) + f(c_2)]
$$

tenga exactitud algebraica igual a $3$, es decir, que sea exacta para los polinomios $f(x) = 1$, $f(x) = x$, $f(x) = x^2$ y $f(x) = x^3$.

---

 1. Caso $f(x) = 1$

$$
\int_a^b 1\,dx = b - a = \frac{b-a}{2}(1 + 1)
$$

Por lo tanto, la fórmula es exacta para funciones constantes.

---

 2. Caso $f(x) = x$

$$
\int_a^b x\,dx = \frac{b^2 - a^2}{2} = \frac{b-a}{2}(c_1 + c_2)
$$

De aquí se obtiene la relación

$$
c_1 + c_2 = a + b
$$

---

 3. Caso $f(x) = x^2$

$$
\int_a^b x^2\,dx = \frac{b^3 - a^3}{3} = \frac{b-a}{2}(c_1^2 + c_2^2)
$$

Simplificando,

$$
c_1^2 + c_2^2 = \frac{2}{3}(a^2 + ab + b^2)
$$

Definimos las sumas simétricas

$$
S_1 = c_1 + c_2 = a + b, \quad S_2 = c_1 c_2
$$

Entonces,

$$
S_1^2 - 2S_2 = \frac{2}{3}(a^2 + ab + b^2)
$$

De donde

$$
S_2 = \frac{a^2 + 4ab + b^2}{6}
$$

---

 4. Cálculo de los puntos $c_1$ y $c_2$

Después de desarrollar un poco el sistema de ecuaciones dado por los casos 2 y 3, se nota que los puntos $c_1$ y $c_2$ son las raíces del polinomio cuadrático

$$
t^2 - S_1 t + S_2 = 0
$$

es decir,

$$
c_{1,2} = \frac{S_1 \pm \sqrt{S_1^2 - 4S_2}}{2}
$$

Sustituyendo los valores de $S_1$ y $S_2$,

$$
S_1^2 - 4S_2 = (a+b)^2 - \frac{4(a^2 + 4ab + b^2)}{6} = \frac{(b - a)^2}{3}
$$

Por tanto,

$$
\boxed{
c_1 = \frac{a+b}{2} - \frac{b-a}{2\sqrt{3}}, \quad
c_2 = \frac{a+b}{2} + \frac{b-a}{2\sqrt{3}}
}
$$

Como $0 < 1/\sqrt{3} < 1$, se cumple que $c_1$ y $c_2$ pertenecen al intervalo $[a,b]$.

---

 5. Caso $f(x) = x^3$

Usando la identidad

$$
c_1^3 + c_2^3 = S_1^3 - 3S_1S_2
$$

y sustituyendo los valores de $S_1$ y $S_2$, se verifica que la igualdad también se cumple para $f(x) = x^3$.

---

Por tanto, existen $c_1$ y $c_2$ en $[a,b]$ tales que

$$
\int_a^b f(x)\,dx = \frac{b-a}{2}[f(c_1) + f(c_2)] + E(f)
$$

y la fórmula tiene exactitud algebraica igual a $3$.  

# Ejercicio 23

::: {.callout-note title="Instrucción del ejercicio 23"}

Usando **integración numérica**, escriba un procedimiento en **R** que permita obtener para una función dada $f(x)$ su **polinomio trigonométrico $S_n(x)$**,  
es decir, una **aproximación a su Serie de Fourier**.

:::



::: {.callout-note title="Instrucción del inciso (a)"}

Si se definen:

$$
\phi_0(x) = \frac{1}{\sqrt{2\pi}},
$$

$$
\phi_k(x) = \frac{1}{\sqrt{\pi}} \cos(kx), \quad k = 1, 2, \ldots, n,
$$

$$
\phi_{n+k}(x) = \frac{1}{\sqrt{\pi}} \sin(kx), \quad k = 1, 2, \ldots, n-1.
$$

Pruebe que el conjunto  

$$
B = \{\phi_0, \phi_1, \ldots, \phi_{2n-1}\}
$$

es **ortogonal** con el producto interno integral en el intervalo $[-\pi, \pi]$.  

Dada $f \in C[-\pi, \pi]$, su polinomio trigonométrico $S_n(x)$ se define como:

$$
S_n(x) := \sum_{k=0}^{2n-1} a_k \, \phi_k(x),
$$

donde

$$
a_k = \int_{-\pi}^{\pi} f(x)\phi_k(x)\,dx, \quad k = 0, 1, \ldots, 2n-1.
$$

El límite:

$$
\lim_{n \to \infty} S_n(x) = \lim_{n \to \infty} \sum_{k=0}^{2n-1} a_k \phi_k(x)
$$

se denomina **Serie de Fourier** de $f$.

:::

**Solución (a)**  
*(Demostración de la ortogonalidad mediante el cálculo del producto interno entre las funciones base $\phi_i$ y $\phi_j$ y verificación de que el resultado es cero cuando $i \ne j$ y distinto de cero cuando $i = j$.)*


::: {.callout-note title="Instrucción del inciso (b)"}

Usando alguno de los métodos de integración numérica programados anteriormente,  
escriba una función en **R** para calcular:

$$
a_k = \int_{-\pi}^{\pi} f(x)\phi_k(x)\,dx, \quad \text{para cada } k = 0, 1, \ldots, 2n-1.
$$

:::

**Solución (b)**  
*(Implementación en R que use métodos numéricos como Simpson o Romberg para calcular los coeficientes $a_k$.)*

```{r}
coef.fourier <- function(f, k, tipo = "coseno") {

  integrando <- switch(
    tipo,
    "constante" = function(x) f(x),
    "coseno"    = function(x) f(x) * cos(k * x),
    "seno"      = function(x) f(x) * sin(k * x),
    stop("El parámetro 'tipo' debe ser 'constante', 'coseno' o 'seno'.")
  )
  
  # Cálculo del coeficiente según el tipo
  if (tipo == "constante") {
    return((1 / (2 * pi)) * SimpsonCompuesto(integrando, -pi, pi, 200))
  } else {
    return((1 / pi) * SimpsonCompuesto(integrando, -pi, pi, 200))
  }
}
```


::: {.callout-note title="Instrucción del inciso (c)"}

Programe una función en **R** para calcular la suma:

$$
S(n, x) = \sum_{k=0}^{2n-1} a_k \phi_k(x).
$$

:::

**Solución (c)**  
*(Función en R que recibe los coeficientes $a_k$ y las funciones base $\phi_k$ para evaluar $S_n(x)$ en un conjunto de puntos del dominio $[-\pi, \pi]$.)*

```{r}
serie.fourier <- function(f, n, x) {
  a0 <- coef.fourier(f, 0, tipo = "constante")
  suma <- a0
  for (k in 1:n) {
    a_k <- coef.fourier(f, k, tipo = "coseno")
    b_k <- coef.fourier(f, k, tipo = "seno")
    suma <- suma + a_k * cos(k * x) + b_k * sin(k * x)
  }
  return(suma)
}
```

::: {.callout-note title="Instrucción del inciso (d)"}

Con el programa anterior, encontrar $S_n(x)$ para  
$n = 3, 4, 5, 6, 7, 8$  
para la función:

$$
f(x) = 
\begin{cases}
-1, & -\pi < x < 0, \\[0.3em]
1, & 0 < x < \pi.
\end{cases}
$$

Luego grafique $f(x)$ y $S_n(x)$ en un mismo plano para $n = 3, 4, 5, 6, 7, 8$.

:::

**Solución (d)**  
*(Código en R que genera las aproximaciones $S_n(x)$ y grafica las curvas junto con la función original $f(x)$ para observar el fenómeno de Gibbs y la convergencia de la serie de Fourier.)*

```{r}
#| include: false
graficar <- function(funciones, a, b, c = NULL, d = NULL, n = 400,
                     nombres = NULL, titulo = "Gráfico de funciones") {
  # Verificaciones básicas
  stopifnot(is.numeric(a), is.numeric(b), a < b)
  
  # Si se pasa solo una función, la convertimos en lista
  if (is.function(funciones)) {
    funciones <- list(funciones)
  }
  
  # Si no se dan nombres, los generamos automáticamente
  if (is.null(nombres)) {
    nombres <- paste0("f", seq_along(funciones))
  } else if (length(nombres) != length(funciones)) {
    stop("El número de nombres debe coincidir con el número de funciones.")
  }
  
  # Crear secuencia de puntos
  x <- seq(a, b, length.out = n)
  
  # Evaluar cada función y combinar en un solo data frame
  lista_datos <- lapply(seq_along(funciones), function(i) {
    y <- tryCatch(funciones[[i]](x),
                  error = function(e) rep(NA, length(x)))
    data.frame(x = x, y = y, funcion = nombres[i])
  })
  
  datos <- do.call(rbind, lista_datos)
  
  # Crear el gráfico base
  p <- ggplot(datos, aes(x = x, y = y, color = funcion)) +
    geom_line(linewidth = 1) +
    labs(
      title = titulo,
      x = "x",
      y = "f(x)",
      color = "Función"
    ) +
    theme_minimal(base_size = 14) +
    theme(legend.position = "bottom")
  
  # Aplicar límites del eje Y si se proporcionan
  if (!is.null(c) && !is.null(d)) {
    stopifnot(is.numeric(c), is.numeric(d), c < d)
    p <- p + coord_cartesian(ylim = c(c, d))
  }
  
  return(p)
}
```


```{r}
funcion.prueba <- function(x) {
  if (-pi <= x && x < 0) {
    return(-1)
  } else if (0 <= x && x <= pi) {
    return(1)
  } else {
    return(NA)
  }
}

funcion.prueba <- Vectorize(funcion.prueba)

graficar(list(function(x) funcion.prueba(x), function(x) serie.fourier(funcion.prueba, 3, x), function(x) serie.fourier(funcion.prueba, 4, x), function(x) serie.fourier(funcion.prueba, 5, x), function(x) serie.fourier(funcion.prueba, 6, x), function(x) serie.fourier(funcion.prueba, 7, x), function(x) serie.fourier(funcion.prueba, 8, x)), -pi, pi, -2, 2)
```
En este grafico, f1 representa la funcion original, y de f2 a f7 son las series de fourier incrementando n de 3 a 8

